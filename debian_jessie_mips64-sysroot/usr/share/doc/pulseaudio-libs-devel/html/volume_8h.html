<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PulseAudio: volume.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PulseAudio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('volume_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">volume.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Constants and routines for volume handling.  
<a href="#details">More...</a></p>

<p><a href="volume_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpa__cvolume.html">pa_cvolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating a per-channel volume.  <a href="structpa__cvolume.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aded56902e68e0f8ab576339bde55960e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#aded56902e68e0f8ab576339bde55960e">PA_VOLUME_NORM</a>&#160;&#160;&#160;((<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>) 0x10000U)</td></tr>
<tr class="memdesc:aded56902e68e0f8ab576339bde55960e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal volume (100%, 0 dB)  <a href="#aded56902e68e0f8ab576339bde55960e">More...</a><br /></td></tr>
<tr class="separator:aded56902e68e0f8ab576339bde55960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6e4562a3be216d39ad2246f0339f4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a9e6e4562a3be216d39ad2246f0339f4c">PA_VOLUME_MUTED</a>&#160;&#160;&#160;((<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>) 0U)</td></tr>
<tr class="memdesc:a9e6e4562a3be216d39ad2246f0339f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muted (minimal valid) volume (0%, -inf dB)  <a href="#a9e6e4562a3be216d39ad2246f0339f4c">More...</a><br /></td></tr>
<tr class="separator:a9e6e4562a3be216d39ad2246f0339f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3ad20b0ddc813e847b44afd90488ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#afc3ad20b0ddc813e847b44afd90488ca">PA_VOLUME_MAX</a>&#160;&#160;&#160;((<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>) UINT32_MAX/2)</td></tr>
<tr class="memdesc:afc3ad20b0ddc813e847b44afd90488ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum valid volume we can store.  <a href="#afc3ad20b0ddc813e847b44afd90488ca">More...</a><br /></td></tr>
<tr class="separator:afc3ad20b0ddc813e847b44afd90488ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353b44010677b005abd390af732eb86e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a353b44010677b005abd390af732eb86e">PA_VOLUME_UI_MAX</a>&#160;&#160;&#160;(<a class="el" href="volume_8h.html#ad638dfbc737f126e743584665ea8f557">pa_sw_volume_from_dB</a>(+11.0))</td></tr>
<tr class="memdesc:a353b44010677b005abd390af732eb86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recommended maximum volume to show in user facing UIs.  <a href="#a353b44010677b005abd390af732eb86e">More...</a><br /></td></tr>
<tr class="separator:a353b44010677b005abd390af732eb86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f4578d6ad789317d2a2fb88195a732"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#ae9f4578d6ad789317d2a2fb88195a732">PA_VOLUME_INVALID</a>&#160;&#160;&#160;((<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>) UINT32_MAX)</td></tr>
<tr class="memdesc:ae9f4578d6ad789317d2a2fb88195a732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special 'invalid' volume.  <a href="#ae9f4578d6ad789317d2a2fb88195a732">More...</a><br /></td></tr>
<tr class="separator:ae9f4578d6ad789317d2a2fb88195a732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5f548dcb2b8c7de09bd83e2adccd2d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#ada5f548dcb2b8c7de09bd83e2adccd2d">PA_VOLUME_IS_VALID</a>(v)&#160;&#160;&#160;((v) &lt;= <a class="el" href="volume_8h.html#afc3ad20b0ddc813e847b44afd90488ca">PA_VOLUME_MAX</a>)</td></tr>
<tr class="memdesc:ada5f548dcb2b8c7de09bd83e2adccd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if volume is valid.  <a href="#ada5f548dcb2b8c7de09bd83e2adccd2d">More...</a><br /></td></tr>
<tr class="separator:ada5f548dcb2b8c7de09bd83e2adccd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4e15efd8cadecc75b1da13cfe50708"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a7c4e15efd8cadecc75b1da13cfe50708">PA_CLAMP_VOLUME</a>(v)&#160;&#160;&#160;(PA_CLAMP_UNLIKELY((v), <a class="el" href="volume_8h.html#a9e6e4562a3be216d39ad2246f0339f4c">PA_VOLUME_MUTED</a>, <a class="el" href="volume_8h.html#afc3ad20b0ddc813e847b44afd90488ca">PA_VOLUME_MAX</a>))</td></tr>
<tr class="memdesc:a7c4e15efd8cadecc75b1da13cfe50708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp volume to the permitted range.  <a href="#a7c4e15efd8cadecc75b1da13cfe50708">More...</a><br /></td></tr>
<tr class="separator:a7c4e15efd8cadecc75b1da13cfe50708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2701828c290031c9bca9036f5148c72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#aa2701828c290031c9bca9036f5148c72">pa_cvolume_reset</a>(a, n)&#160;&#160;&#160;<a class="el" href="volume_8h.html#a0777581d85a1d4bf9c831bdacaac51ac">pa_cvolume_set</a>((a), (n), <a class="el" href="volume_8h.html#aded56902e68e0f8ab576339bde55960e">PA_VOLUME_NORM</a>)</td></tr>
<tr class="memdesc:aa2701828c290031c9bca9036f5148c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the volume of the first n channels to PA_VOLUME_NORM.  <a href="#aa2701828c290031c9bca9036f5148c72">More...</a><br /></td></tr>
<tr class="separator:aa2701828c290031c9bca9036f5148c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04805cb4b83ded75deca9c122977d8fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a04805cb4b83ded75deca9c122977d8fb">pa_cvolume_mute</a>(a, n)&#160;&#160;&#160;<a class="el" href="volume_8h.html#a0777581d85a1d4bf9c831bdacaac51ac">pa_cvolume_set</a>((a), (n), <a class="el" href="volume_8h.html#a9e6e4562a3be216d39ad2246f0339f4c">PA_VOLUME_MUTED</a>)</td></tr>
<tr class="memdesc:a04805cb4b83ded75deca9c122977d8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the volume of the first n channels to PA_VOLUME_MUTED.  <a href="#a04805cb4b83ded75deca9c122977d8fb">More...</a><br /></td></tr>
<tr class="separator:a04805cb4b83ded75deca9c122977d8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4162617e79bec0c7972326cf28a98712"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a4162617e79bec0c7972326cf28a98712">PA_CVOLUME_SNPRINT_MAX</a>&#160;&#160;&#160;320</td></tr>
<tr class="memdesc:a4162617e79bec0c7972326cf28a98712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the strings returned by <a class="el" href="volume_8h.html#a99f2e389f425b888d3a02ade86d7c85f" title="Pretty print a volume structure. ">pa_cvolume_snprint()</a>.  <a href="#a4162617e79bec0c7972326cf28a98712">More...</a><br /></td></tr>
<tr class="separator:a4162617e79bec0c7972326cf28a98712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516da5ed0f43f2ff41792fef4466115"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#ac516da5ed0f43f2ff41792fef4466115">PA_SW_CVOLUME_SNPRINT_DB_MAX</a>&#160;&#160;&#160;448</td></tr>
<tr class="memdesc:ac516da5ed0f43f2ff41792fef4466115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the strings returned by <a class="el" href="volume_8h.html#aaf68a0e6959d18e192104802aab25717" title="Pretty print a volume structure but show dB values. ">pa_sw_cvolume_snprint_dB()</a>.  <a href="#ac516da5ed0f43f2ff41792fef4466115">More...</a><br /></td></tr>
<tr class="separator:ac516da5ed0f43f2ff41792fef4466115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d1f1ca4bdb2ff994359b1d990c3409"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#ab7d1f1ca4bdb2ff994359b1d990c3409">PA_CVOLUME_SNPRINT_VERBOSE_MAX</a>&#160;&#160;&#160;1984</td></tr>
<tr class="memdesc:ab7d1f1ca4bdb2ff994359b1d990c3409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the strings returned by <a class="el" href="volume_8h.html#af0baded5d879ad10d0346a1197050d5d" title="Pretty print a volume structure in a verbose way. ">pa_cvolume_snprint_verbose()</a>.  <a href="#ab7d1f1ca4bdb2ff994359b1d990c3409">More...</a><br /></td></tr>
<tr class="separator:ab7d1f1ca4bdb2ff994359b1d990c3409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80190278ec6e8506092d3d57d309234f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a80190278ec6e8506092d3d57d309234f">PA_VOLUME_SNPRINT_MAX</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a80190278ec6e8506092d3d57d309234f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the strings returned by <a class="el" href="volume_8h.html#a379a97102f5b88dc82ccccffc95b8aac" title="Pretty print a volume. ">pa_volume_snprint()</a>.  <a href="#a80190278ec6e8506092d3d57d309234f">More...</a><br /></td></tr>
<tr class="separator:a80190278ec6e8506092d3d57d309234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98deb2bff93c29e036c4cc14ad3d2e8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a98deb2bff93c29e036c4cc14ad3d2e8f">PA_SW_VOLUME_SNPRINT_DB_MAX</a>&#160;&#160;&#160;11</td></tr>
<tr class="memdesc:a98deb2bff93c29e036c4cc14ad3d2e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the strings returned by <a class="el" href="volume_8h.html#abcf6e407dfaec50edc13a994b2b0d9f9" title="Pretty print a volume but show dB values. ">pa_sw_volume_snprint_dB()</a>.  <a href="#a98deb2bff93c29e036c4cc14ad3d2e8f">More...</a><br /></td></tr>
<tr class="separator:a98deb2bff93c29e036c4cc14ad3d2e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546b59e4beef2b68844be4e607dc0eb9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a546b59e4beef2b68844be4e607dc0eb9">PA_VOLUME_SNPRINT_VERBOSE_MAX</a>&#160;&#160;&#160;35</td></tr>
<tr class="memdesc:a546b59e4beef2b68844be4e607dc0eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the strings returned by <a class="el" href="volume_8h.html#a00deddcbf932452475a4b3606f3859f9" title="Pretty print a volume in a verbose way. ">pa_volume_snprint_verbose()</a>.  <a href="#a546b59e4beef2b68844be4e607dc0eb9">More...</a><br /></td></tr>
<tr class="separator:a546b59e4beef2b68844be4e607dc0eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8766a2f30420a83457d2e1f0f139b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a6b8766a2f30420a83457d2e1f0f139b2">pa_cvolume_is_muted</a>(a)&#160;&#160;&#160;<a class="el" href="volume_8h.html#a2dd140d5c2fadd1d8cb7aa0eace05109">pa_cvolume_channels_equal_to</a>((a), <a class="el" href="volume_8h.html#a9e6e4562a3be216d39ad2246f0339f4c">PA_VOLUME_MUTED</a>)</td></tr>
<tr class="memdesc:a6b8766a2f30420a83457d2e1f0f139b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the specified volume has all channels muted.  <a href="#a6b8766a2f30420a83457d2e1f0f139b2">More...</a><br /></td></tr>
<tr class="separator:a6b8766a2f30420a83457d2e1f0f139b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b374bbe16de9ac047fc4e5f6994390c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a0b374bbe16de9ac047fc4e5f6994390c">pa_cvolume_is_norm</a>(a)&#160;&#160;&#160;<a class="el" href="volume_8h.html#a2dd140d5c2fadd1d8cb7aa0eace05109">pa_cvolume_channels_equal_to</a>((a), <a class="el" href="volume_8h.html#aded56902e68e0f8ab576339bde55960e">PA_VOLUME_NORM</a>)</td></tr>
<tr class="memdesc:a0b374bbe16de9ac047fc4e5f6994390c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the specified volume has all channels on normal level.  <a href="#a0b374bbe16de9ac047fc4e5f6994390c">More...</a><br /></td></tr>
<tr class="separator:a0b374bbe16de9ac047fc4e5f6994390c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b917d42c58310ed848916058d75f27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#ae0b917d42c58310ed848916058d75f27">PA_DECIBEL_MININFTY</a>&#160;&#160;&#160;((double) -200.0)</td></tr>
<tr class="memdesc:ae0b917d42c58310ed848916058d75f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This floor value is used as minus infinity when using <a class="el" href="volume_8h.html#a297851419c1e994d9fd2cfbb49aa480a" title="Convert a volume to a decibel value (amplitude, not power). ">pa_sw_volume_to_dB()</a> / <a class="el" href="volume_8h.html#ad638dfbc737f126e743584665ea8f557" title="Convert a decibel value to a volume (amplitude, not power). ">pa_sw_volume_from_dB()</a>.  <a href="#ae0b917d42c58310ed848916058d75f27">More...</a><br /></td></tr>
<tr class="separator:ae0b917d42c58310ed848916058d75f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6d671c65284ff2e94d3773c7368a0352"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a></td></tr>
<tr class="memdesc:a6d671c65284ff2e94d3773c7368a0352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume specification: PA_VOLUME_MUTED: silence; &lt; PA_VOLUME_NORM: decreased volume; PA_VOLUME_NORM: normal volume; </p><blockquote class="doxtable">
<p>PA_VOLUME_NORM: increased volume </p>
</blockquote>
 <a href="#a6d671c65284ff2e94d3773c7368a0352">More...</a><br /></td></tr>
<tr class="separator:a6d671c65284ff2e94d3773c7368a0352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58db6e157e614cf9699c5bead1552380"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpa__cvolume.html">pa_cvolume</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a58db6e157e614cf9699c5bead1552380">pa_cvolume</a></td></tr>
<tr class="memdesc:a58db6e157e614cf9699c5bead1552380"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating a per-channel volume.  <a href="#a58db6e157e614cf9699c5bead1552380">More...</a><br /></td></tr>
<tr class="separator:a58db6e157e614cf9699c5bead1552380"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a84b52cdbff47aad9c058df783f342b57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a84b52cdbff47aad9c058df783f342b57">pa_cvolume_equal</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *b) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:a84b52cdbff47aad9c058df783f342b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return non-zero when *a == *b.  <a href="#a84b52cdbff47aad9c058df783f342b57">More...</a><br /></td></tr>
<tr class="separator:a84b52cdbff47aad9c058df783f342b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdc24192547d6ef3d5b32e746016e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a6fdc24192547d6ef3d5b32e746016e22">pa_cvolume_init</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a)</td></tr>
<tr class="memdesc:a6fdc24192547d6ef3d5b32e746016e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the specified volume and return a pointer to it.  <a href="#a6fdc24192547d6ef3d5b32e746016e22">More...</a><br /></td></tr>
<tr class="separator:a6fdc24192547d6ef3d5b32e746016e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0777581d85a1d4bf9c831bdacaac51ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a0777581d85a1d4bf9c831bdacaac51ac">pa_cvolume_set</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, unsigned channels, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> v)</td></tr>
<tr class="memdesc:a0777581d85a1d4bf9c831bdacaac51ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the volume of the specified number of channels to the volume v.  <a href="#a0777581d85a1d4bf9c831bdacaac51ac">More...</a><br /></td></tr>
<tr class="separator:a0777581d85a1d4bf9c831bdacaac51ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f2e389f425b888d3a02ade86d7c85f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a99f2e389f425b888d3a02ade86d7c85f">pa_cvolume_snprint</a> (char *s, size_t l, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *c)</td></tr>
<tr class="memdesc:a99f2e389f425b888d3a02ade86d7c85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print a volume structure.  <a href="#a99f2e389f425b888d3a02ade86d7c85f">More...</a><br /></td></tr>
<tr class="separator:a99f2e389f425b888d3a02ade86d7c85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf68a0e6959d18e192104802aab25717"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#aaf68a0e6959d18e192104802aab25717">pa_sw_cvolume_snprint_dB</a> (char *s, size_t l, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *c)</td></tr>
<tr class="memdesc:aaf68a0e6959d18e192104802aab25717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print a volume structure but show dB values.  <a href="#aaf68a0e6959d18e192104802aab25717">More...</a><br /></td></tr>
<tr class="separator:aaf68a0e6959d18e192104802aab25717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0baded5d879ad10d0346a1197050d5d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#af0baded5d879ad10d0346a1197050d5d">pa_cvolume_snprint_verbose</a> (char *s, size_t l, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *c, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map, int print_dB)</td></tr>
<tr class="memdesc:af0baded5d879ad10d0346a1197050d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print a volume structure in a verbose way.  <a href="#af0baded5d879ad10d0346a1197050d5d">More...</a><br /></td></tr>
<tr class="separator:af0baded5d879ad10d0346a1197050d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379a97102f5b88dc82ccccffc95b8aac"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a379a97102f5b88dc82ccccffc95b8aac">pa_volume_snprint</a> (char *s, size_t l, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> v)</td></tr>
<tr class="memdesc:a379a97102f5b88dc82ccccffc95b8aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print a volume.  <a href="#a379a97102f5b88dc82ccccffc95b8aac">More...</a><br /></td></tr>
<tr class="separator:a379a97102f5b88dc82ccccffc95b8aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf6e407dfaec50edc13a994b2b0d9f9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#abcf6e407dfaec50edc13a994b2b0d9f9">pa_sw_volume_snprint_dB</a> (char *s, size_t l, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> v)</td></tr>
<tr class="memdesc:abcf6e407dfaec50edc13a994b2b0d9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print a volume but show dB values.  <a href="#abcf6e407dfaec50edc13a994b2b0d9f9">More...</a><br /></td></tr>
<tr class="separator:abcf6e407dfaec50edc13a994b2b0d9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00deddcbf932452475a4b3606f3859f9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a00deddcbf932452475a4b3606f3859f9">pa_volume_snprint_verbose</a> (char *s, size_t l, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> v, int print_dB)</td></tr>
<tr class="memdesc:a00deddcbf932452475a4b3606f3859f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print a volume in a verbose way.  <a href="#a00deddcbf932452475a4b3606f3859f9">More...</a><br /></td></tr>
<tr class="separator:a00deddcbf932452475a4b3606f3859f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f34f2c6d1b4738bf7f11ff06775dc1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a0f34f2c6d1b4738bf7f11ff06775dc1f">pa_cvolume_avg</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:a0f34f2c6d1b4738bf7f11ff06775dc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the average volume of all channels.  <a href="#a0f34f2c6d1b4738bf7f11ff06775dc1f">More...</a><br /></td></tr>
<tr class="separator:a0f34f2c6d1b4738bf7f11ff06775dc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1631e5a8e8a48bb67b600dee21c33e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a1631e5a8e8a48bb67b600dee21c33e44">pa_cvolume_avg_mask</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *cm, <a class="el" href="channelmap_8h.html#a7523d4554f7ffdcf6a9c8b1333741877">pa_channel_position_mask_t</a> mask) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:a1631e5a8e8a48bb67b600dee21c33e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the average volume of all channels that are included in the specified channel map with the specified channel position mask.  <a href="#a1631e5a8e8a48bb67b600dee21c33e44">More...</a><br /></td></tr>
<tr class="separator:a1631e5a8e8a48bb67b600dee21c33e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d65b3af7da133c78ce9def86ea54ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a8d65b3af7da133c78ce9def86ea54ba9">pa_cvolume_max</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:a8d65b3af7da133c78ce9def86ea54ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum volume of all channels.  <a href="#a8d65b3af7da133c78ce9def86ea54ba9">More...</a><br /></td></tr>
<tr class="separator:a8d65b3af7da133c78ce9def86ea54ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d52a8d30a0042c3aaf064ab40b3047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a45d52a8d30a0042c3aaf064ab40b3047">pa_cvolume_max_mask</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *cm, <a class="el" href="channelmap_8h.html#a7523d4554f7ffdcf6a9c8b1333741877">pa_channel_position_mask_t</a> mask) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:a45d52a8d30a0042c3aaf064ab40b3047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum volume of all channels that are included in the specified channel map with the specified channel position mask.  <a href="#a45d52a8d30a0042c3aaf064ab40b3047">More...</a><br /></td></tr>
<tr class="separator:a45d52a8d30a0042c3aaf064ab40b3047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9d43b101bbe3e07b55935fe5dbb3f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#acf9d43b101bbe3e07b55935fe5dbb3f3">pa_cvolume_min</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:acf9d43b101bbe3e07b55935fe5dbb3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum volume of all channels.  <a href="#acf9d43b101bbe3e07b55935fe5dbb3f3">More...</a><br /></td></tr>
<tr class="separator:acf9d43b101bbe3e07b55935fe5dbb3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fb6aef11c33f84a9034f31a2f977b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#aa0fb6aef11c33f84a9034f31a2f977b2">pa_cvolume_min_mask</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *cm, <a class="el" href="channelmap_8h.html#a7523d4554f7ffdcf6a9c8b1333741877">pa_channel_position_mask_t</a> mask) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:aa0fb6aef11c33f84a9034f31a2f977b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum volume of all channels that are included in the specified channel map with the specified channel position mask.  <a href="#aa0fb6aef11c33f84a9034f31a2f977b2">More...</a><br /></td></tr>
<tr class="separator:aa0fb6aef11c33f84a9034f31a2f977b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba14d00682b29838ef39ca5a9afe8972"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#aba14d00682b29838ef39ca5a9afe8972">pa_cvolume_valid</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:aba14d00682b29838ef39ca5a9afe8972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return non-zero when the passed cvolume structure is valid.  <a href="#aba14d00682b29838ef39ca5a9afe8972">More...</a><br /></td></tr>
<tr class="separator:aba14d00682b29838ef39ca5a9afe8972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd140d5c2fadd1d8cb7aa0eace05109"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a2dd140d5c2fadd1d8cb7aa0eace05109">pa_cvolume_channels_equal_to</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> v) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:a2dd140d5c2fadd1d8cb7aa0eace05109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return non-zero if the volume of all channels is equal to the specified value.  <a href="#a2dd140d5c2fadd1d8cb7aa0eace05109">More...</a><br /></td></tr>
<tr class="separator:a2dd140d5c2fadd1d8cb7aa0eace05109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca01f5bd640e7c5b2d3a6dad9093226"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a1ca01f5bd640e7c5b2d3a6dad9093226">pa_sw_volume_multiply</a> (<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> a, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> b) <a class="el" href="gccmacro_8h.html#a318a98dce3b37977670c87a74c173b16">PA_GCC_CONST</a></td></tr>
<tr class="memdesc:a1ca01f5bd640e7c5b2d3a6dad9093226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two volume specifications, return the result.  <a href="#a1ca01f5bd640e7c5b2d3a6dad9093226">More...</a><br /></td></tr>
<tr class="separator:a1ca01f5bd640e7c5b2d3a6dad9093226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae924bdad225c405c1e2f40c22b041b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a6ae924bdad225c405c1e2f40c22b041b">pa_sw_cvolume_multiply</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *dest, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *b)</td></tr>
<tr class="memdesc:a6ae924bdad225c405c1e2f40c22b041b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two per-channel volumes and return the result in *dest.  <a href="#a6ae924bdad225c405c1e2f40c22b041b">More...</a><br /></td></tr>
<tr class="separator:a6ae924bdad225c405c1e2f40c22b041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d040698f798c6cdb100771c7835c7a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a3d040698f798c6cdb100771c7835c7a8">pa_sw_cvolume_multiply_scalar</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *dest, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> b)</td></tr>
<tr class="memdesc:a3d040698f798c6cdb100771c7835c7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a per-channel volume with a scalar volume and return the result in *dest.  <a href="#a3d040698f798c6cdb100771c7835c7a8">More...</a><br /></td></tr>
<tr class="separator:a3d040698f798c6cdb100771c7835c7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf659351cef912786f53132664fa2b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#adcf659351cef912786f53132664fa2b4">pa_sw_volume_divide</a> (<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> a, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> b) <a class="el" href="gccmacro_8h.html#a318a98dce3b37977670c87a74c173b16">PA_GCC_CONST</a></td></tr>
<tr class="memdesc:adcf659351cef912786f53132664fa2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide two volume specifications, return the result.  <a href="#adcf659351cef912786f53132664fa2b4">More...</a><br /></td></tr>
<tr class="separator:adcf659351cef912786f53132664fa2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7392cdb5137cedc579891ac4c8c6ff7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a7392cdb5137cedc579891ac4c8c6ff7d">pa_sw_cvolume_divide</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *dest, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *b)</td></tr>
<tr class="memdesc:a7392cdb5137cedc579891ac4c8c6ff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide two per-channel volumes and return the result in *dest.  <a href="#a7392cdb5137cedc579891ac4c8c6ff7d">More...</a><br /></td></tr>
<tr class="separator:a7392cdb5137cedc579891ac4c8c6ff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f20d6c7da8d906f704ced36055b555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#ae4f20d6c7da8d906f704ced36055b555">pa_sw_cvolume_divide_scalar</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *dest, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> b)</td></tr>
<tr class="memdesc:ae4f20d6c7da8d906f704ced36055b555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a per-channel volume by a scalar volume and return the result in *dest.  <a href="#ae4f20d6c7da8d906f704ced36055b555">More...</a><br /></td></tr>
<tr class="separator:ae4f20d6c7da8d906f704ced36055b555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad638dfbc737f126e743584665ea8f557"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#ad638dfbc737f126e743584665ea8f557">pa_sw_volume_from_dB</a> (double f) <a class="el" href="gccmacro_8h.html#a318a98dce3b37977670c87a74c173b16">PA_GCC_CONST</a></td></tr>
<tr class="memdesc:ad638dfbc737f126e743584665ea8f557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a decibel value to a volume (amplitude, not power).  <a href="#ad638dfbc737f126e743584665ea8f557">More...</a><br /></td></tr>
<tr class="separator:ad638dfbc737f126e743584665ea8f557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297851419c1e994d9fd2cfbb49aa480a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a297851419c1e994d9fd2cfbb49aa480a">pa_sw_volume_to_dB</a> (<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> v) <a class="el" href="gccmacro_8h.html#a318a98dce3b37977670c87a74c173b16">PA_GCC_CONST</a></td></tr>
<tr class="memdesc:a297851419c1e994d9fd2cfbb49aa480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a volume to a decibel value (amplitude, not power).  <a href="#a297851419c1e994d9fd2cfbb49aa480a">More...</a><br /></td></tr>
<tr class="separator:a297851419c1e994d9fd2cfbb49aa480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb4825a03178ee327e55ae0866b7471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#aafb4825a03178ee327e55ae0866b7471">pa_sw_volume_from_linear</a> (double v) <a class="el" href="gccmacro_8h.html#a318a98dce3b37977670c87a74c173b16">PA_GCC_CONST</a></td></tr>
<tr class="memdesc:aafb4825a03178ee327e55ae0866b7471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a linear factor to a volume.  <a href="#aafb4825a03178ee327e55ae0866b7471">More...</a><br /></td></tr>
<tr class="separator:aafb4825a03178ee327e55ae0866b7471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04da6c4572a758a0244bbfc81d370cfb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a04da6c4572a758a0244bbfc81d370cfb">pa_sw_volume_to_linear</a> (<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> v) <a class="el" href="gccmacro_8h.html#a318a98dce3b37977670c87a74c173b16">PA_GCC_CONST</a></td></tr>
<tr class="memdesc:a04da6c4572a758a0244bbfc81d370cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a volume to a linear factor.  <a href="#a04da6c4572a758a0244bbfc81d370cfb">More...</a><br /></td></tr>
<tr class="separator:a04da6c4572a758a0244bbfc81d370cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eab9b175690ff534492673ad30ed2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a5eab9b175690ff534492673ad30ed2e7">pa_cvolume_remap</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *from, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *to)</td></tr>
<tr class="memdesc:a5eab9b175690ff534492673ad30ed2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a volume from one channel mapping to a different channel mapping.  <a href="#a5eab9b175690ff534492673ad30ed2e7">More...</a><br /></td></tr>
<tr class="separator:a5eab9b175690ff534492673ad30ed2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f315d36ea592c0e91407db899e5fab5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a9f315d36ea592c0e91407db899e5fab5">pa_cvolume_compatible</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, const <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *ss) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:a9f315d36ea592c0e91407db899e5fab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return non-zero if the specified volume is compatible with the specified sample spec.  <a href="#a9f315d36ea592c0e91407db899e5fab5">More...</a><br /></td></tr>
<tr class="separator:a9f315d36ea592c0e91407db899e5fab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15263326cff59a120509bafd24565c1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a15263326cff59a120509bafd24565c1d">pa_cvolume_compatible_with_channel_map</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *cm) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:a15263326cff59a120509bafd24565c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return non-zero if the specified volume is compatible with the specified sample spec.  <a href="#a15263326cff59a120509bafd24565c1d">More...</a><br /></td></tr>
<tr class="separator:a15263326cff59a120509bafd24565c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affea337dd40255580c9de68799e569d1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#affea337dd40255580c9de68799e569d1">pa_cvolume_get_balance</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:affea337dd40255580c9de68799e569d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a 'balance' value for the specified volume with the specified channel map.  <a href="#affea337dd40255580c9de68799e569d1">More...</a><br /></td></tr>
<tr class="separator:affea337dd40255580c9de68799e569d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cad9c475a9a318c433f12ff019d7fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a0cad9c475a9a318c433f12ff019d7fec">pa_cvolume_set_balance</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map, float new_balance)</td></tr>
<tr class="memdesc:a0cad9c475a9a318c433f12ff019d7fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the 'balance' value for the specified volume with the specified channel map.  <a href="#a0cad9c475a9a318c433f12ff019d7fec">More...</a><br /></td></tr>
<tr class="separator:a0cad9c475a9a318c433f12ff019d7fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf78aa9297c11860338ffa3c958f9a36"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#aaf78aa9297c11860338ffa3c958f9a36">pa_cvolume_get_fade</a> (const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:aaf78aa9297c11860338ffa3c958f9a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a 'fade' value (i.e. 'balance' between front and rear) for the specified volume with the specified channel map.  <a href="#aaf78aa9297c11860338ffa3c958f9a36">More...</a><br /></td></tr>
<tr class="separator:aaf78aa9297c11860338ffa3c958f9a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4379c7e84379121f4baaba0aefaf76ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a4379c7e84379121f4baaba0aefaf76ee">pa_cvolume_set_fade</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map, float new_fade)</td></tr>
<tr class="memdesc:a4379c7e84379121f4baaba0aefaf76ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the 'fade' value (i.e. 'balance' between front and rear) for the specified volume with the specified channel map.  <a href="#a4379c7e84379121f4baaba0aefaf76ee">More...</a><br /></td></tr>
<tr class="separator:a4379c7e84379121f4baaba0aefaf76ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175fa9c547655cd868b4812755a0a113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a175fa9c547655cd868b4812755a0a113">pa_cvolume_scale</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> max)</td></tr>
<tr class="memdesc:a175fa9c547655cd868b4812755a0a113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the passed <a class="el" href="structpa__cvolume.html" title="A structure encapsulating a per-channel volume. ">pa_cvolume</a> structure so that the maximum volume of all channels equals max.  <a href="#a175fa9c547655cd868b4812755a0a113">More...</a><br /></td></tr>
<tr class="separator:a175fa9c547655cd868b4812755a0a113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830ad2a196782fcac20ab3d3ccf856bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a830ad2a196782fcac20ab3d3ccf856bf">pa_cvolume_scale_mask</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> max, <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *cm, <a class="el" href="channelmap_8h.html#a7523d4554f7ffdcf6a9c8b1333741877">pa_channel_position_mask_t</a> mask)</td></tr>
<tr class="memdesc:a830ad2a196782fcac20ab3d3ccf856bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the passed <a class="el" href="structpa__cvolume.html" title="A structure encapsulating a per-channel volume. ">pa_cvolume</a> structure so that the maximum volume of all channels selected via cm/mask equals max.  <a href="#a830ad2a196782fcac20ab3d3ccf856bf">More...</a><br /></td></tr>
<tr class="separator:a830ad2a196782fcac20ab3d3ccf856bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162e08219b4de7d4bc96d25c8b3e0d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a162e08219b4de7d4bc96d25c8b3e0d44">pa_cvolume_set_position</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *cv, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map, <a class="el" href="channelmap_8h.html#a73a7ec05f42b21cb70ba4405b54177f6">pa_channel_position_t</a> t, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> v)</td></tr>
<tr class="memdesc:a162e08219b4de7d4bc96d25c8b3e0d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the passed volume to all channels at the specified channel position.  <a href="#a162e08219b4de7d4bc96d25c8b3e0d44">More...</a><br /></td></tr>
<tr class="separator:a162e08219b4de7d4bc96d25c8b3e0d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50b7a4b2e1335e0d3ba4a64d6577b26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#aa50b7a4b2e1335e0d3ba4a64d6577b26">pa_cvolume_get_position</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *cv, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map, <a class="el" href="channelmap_8h.html#a73a7ec05f42b21cb70ba4405b54177f6">pa_channel_position_t</a> t) <a class="el" href="gccmacro_8h.html#aa1c5f50faa1073e28ba469b86f6a0548">PA_GCC_PURE</a></td></tr>
<tr class="memdesc:aa50b7a4b2e1335e0d3ba4a64d6577b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum volume of all channels at the specified channel position.  <a href="#aa50b7a4b2e1335e0d3ba4a64d6577b26">More...</a><br /></td></tr>
<tr class="separator:aa50b7a4b2e1335e0d3ba4a64d6577b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c6b663bfdc7c527475a0690bc7113b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#af7c6b663bfdc7c527475a0690bc7113b">pa_cvolume_merge</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *dest, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *a, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *b)</td></tr>
<tr class="memdesc:af7c6b663bfdc7c527475a0690bc7113b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This goes through all channels in a and b and sets the corresponding channel in dest to the greater volume of both.  <a href="#af7c6b663bfdc7c527475a0690bc7113b">More...</a><br /></td></tr>
<tr class="separator:af7c6b663bfdc7c527475a0690bc7113b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0091f0005e1c097d64af5ba7d088b394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a0091f0005e1c097d64af5ba7d088b394">pa_cvolume_inc_clamp</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> inc, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> limit)</td></tr>
<tr class="memdesc:a0091f0005e1c097d64af5ba7d088b394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the volume passed in by 'inc', but not exceeding 'limit'.  <a href="#a0091f0005e1c097d64af5ba7d088b394">More...</a><br /></td></tr>
<tr class="separator:a0091f0005e1c097d64af5ba7d088b394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b4a370e6fff4b318acd3a7ac055d7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a26b4a370e6fff4b318acd3a7ac055d7a">pa_cvolume_inc</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> inc)</td></tr>
<tr class="memdesc:a26b4a370e6fff4b318acd3a7ac055d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the volume passed in by 'inc'.  <a href="#a26b4a370e6fff4b318acd3a7ac055d7a">More...</a><br /></td></tr>
<tr class="separator:a26b4a370e6fff4b318acd3a7ac055d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d01d4da8c279bd66c0d09c7310ef95c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="volume_8h.html#a3d01d4da8c279bd66c0d09c7310ef95c">pa_cvolume_dec</a> (<a class="el" href="structpa__cvolume.html">pa_cvolume</a> *v, <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> dec)</td></tr>
<tr class="memdesc:a3d01d4da8c279bd66c0d09c7310ef95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the volume passed in by 'dec'.  <a href="#a3d01d4da8c279bd66c0d09c7310ef95c">More...</a><br /></td></tr>
<tr class="separator:a3d01d4da8c279bd66c0d09c7310ef95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Constants and routines for volume handling. </p>
<p>See also <a class="el" href="volume.html">Volume Control</a> </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a7c4e15efd8cadecc75b1da13cfe50708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_CLAMP_VOLUME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v</td><td>)</td>
          <td>&#160;&#160;&#160;(PA_CLAMP_UNLIKELY((v), <a class="el" href="volume_8h.html#a9e6e4562a3be216d39ad2246f0339f4c">PA_VOLUME_MUTED</a>, <a class="el" href="volume_8h.html#afc3ad20b0ddc813e847b44afd90488ca">PA_VOLUME_MAX</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamp volume to the permitted range. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6b8766a2f30420a83457d2e1f0f139b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pa_cvolume_is_muted</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="volume_8h.html#a2dd140d5c2fadd1d8cb7aa0eace05109">pa_cvolume_channels_equal_to</a>((a), <a class="el" href="volume_8h.html#a9e6e4562a3be216d39ad2246f0339f4c">PA_VOLUME_MUTED</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return 1 if the specified volume has all channels muted. </p>

</div>
</div>
<a class="anchor" id="a0b374bbe16de9ac047fc4e5f6994390c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pa_cvolume_is_norm</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="volume_8h.html#a2dd140d5c2fadd1d8cb7aa0eace05109">pa_cvolume_channels_equal_to</a>((a), <a class="el" href="volume_8h.html#aded56902e68e0f8ab576339bde55960e">PA_VOLUME_NORM</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return 1 if the specified volume has all channels on normal level. </p>

</div>
</div>
<a class="anchor" id="a04805cb4b83ded75deca9c122977d8fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pa_cvolume_mute</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="volume_8h.html#a0777581d85a1d4bf9c831bdacaac51ac">pa_cvolume_set</a>((a), (n), <a class="el" href="volume_8h.html#a9e6e4562a3be216d39ad2246f0339f4c">PA_VOLUME_MUTED</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the volume of the first n channels to PA_VOLUME_MUTED. </p>

</div>
</div>
<a class="anchor" id="aa2701828c290031c9bca9036f5148c72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pa_cvolume_reset</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="volume_8h.html#a0777581d85a1d4bf9c831bdacaac51ac">pa_cvolume_set</a>((a), (n), <a class="el" href="volume_8h.html#aded56902e68e0f8ab576339bde55960e">PA_VOLUME_NORM</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the volume of the first n channels to PA_VOLUME_NORM. </p>

</div>
</div>
<a class="anchor" id="a4162617e79bec0c7972326cf28a98712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_CVOLUME_SNPRINT_MAX&#160;&#160;&#160;320</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of the strings returned by <a class="el" href="volume_8h.html#a99f2e389f425b888d3a02ade86d7c85f" title="Pretty print a volume structure. ">pa_cvolume_snprint()</a>. </p>
<p>Please note that this value can change with any release without warning and without being considered API or ABI breakage. You should not use this definition anywhere where it might become part of an ABI. </p>

</div>
</div>
<a class="anchor" id="ab7d1f1ca4bdb2ff994359b1d990c3409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_CVOLUME_SNPRINT_VERBOSE_MAX&#160;&#160;&#160;1984</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of the strings returned by <a class="el" href="volume_8h.html#af0baded5d879ad10d0346a1197050d5d" title="Pretty print a volume structure in a verbose way. ">pa_cvolume_snprint_verbose()</a>. </p>
<p>Please note that this value can change with any release without warning and without being considered API or ABI breakage. You should not use this definition anywhere where it might become part of an ABI. </p><dl class="section since"><dt>Since</dt><dd>5.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ae0b917d42c58310ed848916058d75f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_DECIBEL_MININFTY&#160;&#160;&#160;((double) -200.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This floor value is used as minus infinity when using <a class="el" href="volume_8h.html#a297851419c1e994d9fd2cfbb49aa480a" title="Convert a volume to a decibel value (amplitude, not power). ">pa_sw_volume_to_dB()</a> / <a class="el" href="volume_8h.html#ad638dfbc737f126e743584665ea8f557" title="Convert a decibel value to a volume (amplitude, not power). ">pa_sw_volume_from_dB()</a>. </p>

</div>
</div>
<a class="anchor" id="ac516da5ed0f43f2ff41792fef4466115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_SW_CVOLUME_SNPRINT_DB_MAX&#160;&#160;&#160;448</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of the strings returned by <a class="el" href="volume_8h.html#aaf68a0e6959d18e192104802aab25717" title="Pretty print a volume structure but show dB values. ">pa_sw_cvolume_snprint_dB()</a>. </p>
<p>Please note that this value can change with any release without warning and without being considered API or ABI breakage. You should not use this definition anywhere where it might become part of an ABI. </p><dl class="section since"><dt>Since</dt><dd>0.9.13 </dd></dl>

</div>
</div>
<a class="anchor" id="a98deb2bff93c29e036c4cc14ad3d2e8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_SW_VOLUME_SNPRINT_DB_MAX&#160;&#160;&#160;11</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of the strings returned by <a class="el" href="volume_8h.html#abcf6e407dfaec50edc13a994b2b0d9f9" title="Pretty print a volume but show dB values. ">pa_sw_volume_snprint_dB()</a>. </p>
<p>Please note that this value can change with any release without warning and without being considered API or ABI breakage. You should not use this definition anywhere where it might become part of an ABI. </p><dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="ae9f4578d6ad789317d2a2fb88195a732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_VOLUME_INVALID&#160;&#160;&#160;((<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>) UINT32_MAX)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special 'invalid' volume. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="ada5f548dcb2b8c7de09bd83e2adccd2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_VOLUME_IS_VALID</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v</td><td>)</td>
          <td>&#160;&#160;&#160;((v) &lt;= <a class="el" href="volume_8h.html#afc3ad20b0ddc813e847b44afd90488ca">PA_VOLUME_MAX</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if volume is valid. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="afc3ad20b0ddc813e847b44afd90488ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_VOLUME_MAX&#160;&#160;&#160;((<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>) UINT32_MAX/2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum valid volume we can store. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="a9e6e4562a3be216d39ad2246f0339f4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_VOLUME_MUTED&#160;&#160;&#160;((<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>) 0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muted (minimal valid) volume (0%, -inf dB) </p>

</div>
</div>
<a class="anchor" id="aded56902e68e0f8ab576339bde55960e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_VOLUME_NORM&#160;&#160;&#160;((<a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>) 0x10000U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normal volume (100%, 0 dB) </p>

</div>
</div>
<a class="anchor" id="a80190278ec6e8506092d3d57d309234f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_VOLUME_SNPRINT_MAX&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of the strings returned by <a class="el" href="volume_8h.html#a379a97102f5b88dc82ccccffc95b8aac" title="Pretty print a volume. ">pa_volume_snprint()</a>. </p>
<p>Please note that this value can change with any release without warning and without being considered API or ABI breakage. You should not use this definition anywhere where it might become part of an ABI. </p><dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="a546b59e4beef2b68844be4e607dc0eb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_VOLUME_SNPRINT_VERBOSE_MAX&#160;&#160;&#160;35</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of the strings returned by <a class="el" href="volume_8h.html#a00deddcbf932452475a4b3606f3859f9" title="Pretty print a volume in a verbose way. ">pa_volume_snprint_verbose()</a>. </p>
<p>Please note that this value can change with any release without warning and withou being considered API or ABI breakage. You should not use this definition anywhere where it might become part of an ABI. </p><dl class="section since"><dt>Since</dt><dd>5.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a353b44010677b005abd390af732eb86e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_VOLUME_UI_MAX&#160;&#160;&#160;(<a class="el" href="volume_8h.html#ad638dfbc737f126e743584665ea8f557">pa_sw_volume_from_dB</a>(+11.0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recommended maximum volume to show in user facing UIs. </p>
<p>Note: UIs should deal gracefully with volumes greater than this value and not cause feedback loops etc. - i.e. if the volume is more than this, the UI should not limit it and push the limited value back to the server. </p><dl class="section since"><dt>Since</dt><dd>0.9.23 </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a58db6e157e614cf9699c5bead1552380"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structpa__cvolume.html">pa_cvolume</a>  <a class="el" href="structpa__cvolume.html">pa_cvolume</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A structure encapsulating a per-channel volume. </p>

</div>
</div>
<a class="anchor" id="a6d671c65284ff2e94d3773c7368a0352"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume specification: PA_VOLUME_MUTED: silence; &lt; PA_VOLUME_NORM: decreased volume; PA_VOLUME_NORM: normal volume; </p><blockquote class="doxtable">
<p>PA_VOLUME_NORM: increased volume </p>
</blockquote>
</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0f34f2c6d1b4738bf7f11ff06775dc1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_cvolume_avg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the average volume of all channels. </p>

</div>
</div>
<a class="anchor" id="a1631e5a8e8a48bb67b600dee21c33e44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_cvolume_avg_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>cm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="channelmap_8h.html#a7523d4554f7ffdcf6a9c8b1333741877">pa_channel_position_mask_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the average volume of all channels that are included in the specified channel map with the specified channel position mask. </p>
<p>If cm is NULL this call is identical to <a class="el" href="volume_8h.html#a0f34f2c6d1b4738bf7f11ff06775dc1f" title="Return the average volume of all channels. ">pa_cvolume_avg()</a>. If no channel is selected the returned value will be PA_VOLUME_MUTED. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="a2dd140d5c2fadd1d8cb7aa0eace05109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_cvolume_channels_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return non-zero if the volume of all channels is equal to the specified value. </p>

</div>
</div>
<a class="anchor" id="a9f315d36ea592c0e91407db899e5fab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_cvolume_compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *&#160;</td>
          <td class="paramname"><em>ss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return non-zero if the specified volume is compatible with the specified sample spec. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.13 </dd></dl>

</div>
</div>
<a class="anchor" id="a15263326cff59a120509bafd24565c1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_cvolume_compatible_with_channel_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>cm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return non-zero if the specified volume is compatible with the specified sample spec. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="a3d01d4da8c279bd66c0d09c7310ef95c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_dec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the volume passed in by 'dec'. </p>
<p>The proportions between the channels are kept. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="a84b52cdbff47aad9c058df783f342b57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_cvolume_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return non-zero when *a == *b. </p>

</div>
</div>
<a class="anchor" id="affea337dd40255580c9de68799e569d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pa_cvolume_get_balance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a 'balance' value for the specified volume with the specified channel map. </p>
<p>The return value will range from -1.0f (left) to +1.0f (right). If no balance value is applicable to this channel map the return value will always be 0.0f. See <a class="el" href="channelmap_8h.html#a0ece3ec5671817252fd5e8d804c31452" title="Returns non-zero if it makes sense to apply a volume &#39;balance&#39; with this mapping, i...">pa_channel_map_can_balance()</a>. </p><dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="aaf78aa9297c11860338ffa3c958f9a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pa_cvolume_get_fade </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a 'fade' value (i.e. 'balance' between front and rear) for the specified volume with the specified channel map. </p>
<p>The return value will range from -1.0f (rear) to +1.0f (left). If no fade value is applicable to this channel map the return value will always be 0.0f. See <a class="el" href="channelmap_8h.html#a2204e8c49245a7526dbed708ca9cef05" title="Returns non-zero if it makes sense to apply a volume &#39;fade&#39; (i.e. &#39;balance&#39; between front and rear) w...">pa_channel_map_can_fade()</a>. </p><dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="aa50b7a4b2e1335e0d3ba4a64d6577b26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_cvolume_get_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="channelmap_8h.html#a73a7ec05f42b21cb70ba4405b54177f6">pa_channel_position_t</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum volume of all channels at the specified channel position. </p>
<p>Will return 0 if there is no channel at the position specified. You can check if a channel map includes a specific position by calling <a class="el" href="channelmap_8h.html#aad10ab1e6775ce3b7b5a09927b897bc5" title="Returns non-zero if the specified channel position is available at least once in the channel map...">pa_channel_map_has_position()</a>. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="a26b4a370e6fff4b318acd3a7ac055d7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_inc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the volume passed in by 'inc'. </p>
<p>The proportions between the channels are kept. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="a0091f0005e1c097d64af5ba7d088b394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_inc_clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>inc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the volume passed in by 'inc', but not exceeding 'limit'. </p>
<p>The proportions between the channels are kept. </p><dl class="section since"><dt>Since</dt><dd>0.9.19 </dd></dl>

</div>
</div>
<a class="anchor" id="a6fdc24192547d6ef3d5b32e746016e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the specified volume and return a pointer to it. </p>
<p>The sample spec will have a defined state but <a class="el" href="volume_8h.html#aba14d00682b29838ef39ca5a9afe8972" title="Return non-zero when the passed cvolume structure is valid. ">pa_cvolume_valid()</a> will fail for it. </p><dl class="section since"><dt>Since</dt><dd>0.9.13 </dd></dl>

</div>
</div>
<a class="anchor" id="a8d65b3af7da133c78ce9def86ea54ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_cvolume_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum volume of all channels. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.12 </dd></dl>

</div>
</div>
<a class="anchor" id="a45d52a8d30a0042c3aaf064ab40b3047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_cvolume_max_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>cm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="channelmap_8h.html#a7523d4554f7ffdcf6a9c8b1333741877">pa_channel_position_mask_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum volume of all channels that are included in the specified channel map with the specified channel position mask. </p>
<p>If cm is NULL this call is identical to <a class="el" href="volume_8h.html#a8d65b3af7da133c78ce9def86ea54ba9" title="Return the maximum volume of all channels. ">pa_cvolume_max()</a>. If no channel is selected the returned value will be PA_VOLUME_MUTED. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="af7c6b663bfdc7c527475a0690bc7113b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This goes through all channels in a and b and sets the corresponding channel in dest to the greater volume of both. </p>
<p>a, b and dest may point to the same structure. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="acf9d43b101bbe3e07b55935fe5dbb3f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_cvolume_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum volume of all channels. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="aa0fb6aef11c33f84a9034f31a2f977b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_cvolume_min_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>cm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="channelmap_8h.html#a7523d4554f7ffdcf6a9c8b1333741877">pa_channel_position_mask_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum volume of all channels that are included in the specified channel map with the specified channel position mask. </p>
<p>If cm is NULL this call is identical to <a class="el" href="volume_8h.html#acf9d43b101bbe3e07b55935fe5dbb3f3" title="Return the minimum volume of all channels. ">pa_cvolume_min()</a>. If no channel is selected the returned value will be PA_VOLUME_MUTED. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="a5eab9b175690ff534492673ad30ed2e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap a volume from one channel mapping to a different channel mapping. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.12 </dd></dl>

</div>
</div>
<a class="anchor" id="a175fa9c547655cd868b4812755a0a113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale the passed <a class="el" href="structpa__cvolume.html" title="A structure encapsulating a per-channel volume. ">pa_cvolume</a> structure so that the maximum volume of all channels equals max. </p>
<p>The proportions between the channel volumes are kept. </p><dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="a830ad2a196782fcac20ab3d3ccf856bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_scale_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>cm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="channelmap_8h.html#a7523d4554f7ffdcf6a9c8b1333741877">pa_channel_position_mask_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale the passed <a class="el" href="structpa__cvolume.html" title="A structure encapsulating a per-channel volume. ">pa_cvolume</a> structure so that the maximum volume of all channels selected via cm/mask equals max. </p>
<p>This also modifies the volume of those channels that are unmasked. The proportions between the channel volumes are kept. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="a0777581d85a1d4bf9c831bdacaac51ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the volume of the specified number of channels to the volume v. </p>

</div>
</div>
<a class="anchor" id="a0cad9c475a9a318c433f12ff019d7fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_set_balance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>new_balance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the 'balance' value for the specified volume with the specified channel map. </p>
<p>v will be modified in place and returned. The balance is a value between -1.0f and +1.0f. This operation might not be reversible! Also, after this call <a class="el" href="volume_8h.html#affea337dd40255580c9de68799e569d1" title="Calculate a &#39;balance&#39; value for the specified volume with the specified channel map. ">pa_cvolume_get_balance()</a> is not guaranteed to actually return the requested balance value (e.g. when the input volume was zero anyway for all channels). If no balance value is applicable to this channel map the volume will not be modified. See <a class="el" href="channelmap_8h.html#a0ece3ec5671817252fd5e8d804c31452" title="Returns non-zero if it makes sense to apply a volume &#39;balance&#39; with this mapping, i...">pa_channel_map_can_balance()</a>. </p><dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="a4379c7e84379121f4baaba0aefaf76ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_set_fade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>new_fade</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the 'fade' value (i.e. 'balance' between front and rear) for the specified volume with the specified channel map. </p>
<p>v will be modified in place and returned. The balance is a value between -1.0f and +1.0f. This operation might not be reversible! Also, after this call <a class="el" href="volume_8h.html#aaf78aa9297c11860338ffa3c958f9a36" title="Calculate a &#39;fade&#39; value (i.e. &#39;balance&#39; between front and rear) for the specified volume with the sp...">pa_cvolume_get_fade()</a> is not guaranteed to actually return the requested fade value (e.g. when the input volume was zero anyway for all channels). If no fade value is applicable to this channel map the volume will not be modified. See <a class="el" href="channelmap_8h.html#a2204e8c49245a7526dbed708ca9cef05" title="Returns non-zero if it makes sense to apply a volume &#39;fade&#39; (i.e. &#39;balance&#39; between front and rear) w...">pa_channel_map_can_fade()</a>. </p><dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="a162e08219b4de7d4bc96d25c8b3e0d44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_cvolume_set_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="channelmap_8h.html#a73a7ec05f42b21cb70ba4405b54177f6">pa_channel_position_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the passed volume to all channels at the specified channel position. </p>
<p>Will return the updated volume struct, or NULL if there is no channel at the position specified. You can check if a channel map includes a specific position by calling <a class="el" href="channelmap_8h.html#aad10ab1e6775ce3b7b5a09927b897bc5" title="Returns non-zero if the specified channel position is available at least once in the channel map...">pa_channel_map_has_position()</a>. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="a99f2e389f425b888d3a02ade86d7c85f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pa_cvolume_snprint </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print a volume structure. </p>

</div>
</div>
<a class="anchor" id="af0baded5d879ad10d0346a1197050d5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pa_cvolume_snprint_verbose </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>print_dB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print a volume structure in a verbose way. </p>
<p>The volume for each channel is printed in several formats: the raw pa_volume_t value, percentage, and if print_dB is non-zero, also the dB value. If map is not NULL, the channel names will be printed. </p><dl class="section since"><dt>Since</dt><dd>5.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aba14d00682b29838ef39ca5a9afe8972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_cvolume_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return non-zero when the passed cvolume structure is valid. </p>

</div>
</div>
<a class="anchor" id="a7392cdb5137cedc579891ac4c8c6ff7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_sw_cvolume_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide two per-channel volumes and return the result in *dest. </p>
<p>This is only valid for software volumes! a, b and dest may point to the same structure. </p><dl class="section since"><dt>Since</dt><dd>0.9.13 </dd></dl>

</div>
</div>
<a class="anchor" id="ae4f20d6c7da8d906f704ced36055b555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_sw_cvolume_divide_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a per-channel volume by a scalar volume and return the result in *dest. </p>
<p>This is only valid for software volumes! a and dest may point to the same structure. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="a6ae924bdad225c405c1e2f40c22b041b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_sw_cvolume_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two per-channel volumes and return the result in *dest. </p>
<p>This is only valid for software volumes! a, b and dest may point to the same structure. </p>

</div>
</div>
<a class="anchor" id="a3d040698f798c6cdb100771c7835c7a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__cvolume.html">pa_cvolume</a>* pa_sw_cvolume_multiply_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a per-channel volume with a scalar volume and return the result in *dest. </p>
<p>This is only valid for software volumes! a and dest may point to the same structure. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="aaf68a0e6959d18e192104802aab25717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pa_sw_cvolume_snprint_dB </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print a volume structure but show dB values. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.13 </dd></dl>

</div>
</div>
<a class="anchor" id="adcf659351cef912786f53132664fa2b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_sw_volume_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide two volume specifications, return the result. </p>
<p>This uses PA_VOLUME_NORM as neutral element of division. This is only valid for software volumes! If a division by zero is tried the result will be 0. </p><dl class="section since"><dt>Since</dt><dd>0.9.13 </dd></dl>

</div>
</div>
<a class="anchor" id="ad638dfbc737f126e743584665ea8f557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_sw_volume_from_dB </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a decibel value to a volume (amplitude, not power). </p>
<p>This is only valid for software volumes! </p>

</div>
</div>
<a class="anchor" id="aafb4825a03178ee327e55ae0866b7471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_sw_volume_from_linear </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a linear factor to a volume. </p>
<p>0.0 and less is muted while 1.0 is PA_VOLUME_NORM. This is only valid for software volumes! </p>

</div>
</div>
<a class="anchor" id="a1ca01f5bd640e7c5b2d3a6dad9093226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a> pa_sw_volume_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two volume specifications, return the result. </p>
<p>This uses PA_VOLUME_NORM as neutral element of multiplication. This is only valid for software volumes! </p>

</div>
</div>
<a class="anchor" id="abcf6e407dfaec50edc13a994b2b0d9f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pa_sw_volume_snprint_dB </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print a volume but show dB values. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="a297851419c1e994d9fd2cfbb49aa480a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double pa_sw_volume_to_dB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a volume to a decibel value (amplitude, not power). </p>
<p>This is only valid for software volumes! </p>

</div>
</div>
<a class="anchor" id="a04da6c4572a758a0244bbfc81d370cfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double pa_sw_volume_to_linear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a volume to a linear factor. </p>
<p>This is only valid for software volumes! </p>

</div>
</div>
<a class="anchor" id="a379a97102f5b88dc82ccccffc95b8aac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pa_volume_snprint </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print a volume. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="a00deddcbf932452475a4b3606f3859f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pa_volume_snprint_verbose </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="volume_8h.html#a6d671c65284ff2e94d3773c7368a0352">pa_volume_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>print_dB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print a volume in a verbose way. </p>
<p>The volume is printed in several formats: the raw pa_volume_t value, percentage, and if print_dB is non-zero, also the dB value. </p><dl class="section since"><dt>Since</dt><dd>5.0 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_ec5b0a79aff2db41fe5d1b9326f09c28.html">pulse</a></li><li class="navelem"><a class="el" href="volume_8h.html">volume.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
