<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PulseAudio: stream.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PulseAudio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('stream_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">stream.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Audio streams for input, output and sample upload.  
<a href="#details">More...</a></p>

<p><a href="stream_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a960d798980692a2ff01e5a70553d4f29"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a></td></tr>
<tr class="memdesc:a960d798980692a2ff01e5a70553d4f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque stream for playback or recording.  <a href="#a960d798980692a2ff01e5a70553d4f29">More...</a><br /></td></tr>
<tr class="separator:a960d798980692a2ff01e5a70553d4f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db8260c2273ec4ddd51e0ff9fa198b0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> )(<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, int success, void *userdata)</td></tr>
<tr class="memdesc:a4db8260c2273ec4ddd51e0ff9fa198b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic callback for operation completion.  <a href="#a4db8260c2273ec4ddd51e0ff9fa198b0">More...</a><br /></td></tr>
<tr class="separator:a4db8260c2273ec4ddd51e0ff9fa198b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47304c180a358523bed4020e38001d61"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a47304c180a358523bed4020e38001d61">pa_stream_request_cb_t</a> )(<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, size_t nbytes, void *userdata)</td></tr>
<tr class="memdesc:a47304c180a358523bed4020e38001d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic request callback.  <a href="#a47304c180a358523bed4020e38001d61">More...</a><br /></td></tr>
<tr class="separator:a47304c180a358523bed4020e38001d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2adcc8f27af8241005f3388e7081ccc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a> )(<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, void *userdata)</td></tr>
<tr class="memdesc:ad2adcc8f27af8241005f3388e7081ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic notification callback.  <a href="#ad2adcc8f27af8241005f3388e7081ccc">More...</a><br /></td></tr>
<tr class="separator:ad2adcc8f27af8241005f3388e7081ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d668892312b7e651cdf737336710e6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a56d668892312b7e651cdf737336710e6">pa_stream_event_cb_t</a> )(<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, const char *name, <a class="el" href="proplist_8h.html#acdf756a6014b6fae3b358b2c934c3426">pa_proplist</a> *pl, void *userdata)</td></tr>
<tr class="memdesc:a56d668892312b7e651cdf737336710e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback for asynchronous meta/policy event messages.  <a href="#a56d668892312b7e651cdf737336710e6">More...</a><br /></td></tr>
<tr class="separator:a56d668892312b7e651cdf737336710e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab95a64207d12a1da61d31289d8b3ff3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ab95a64207d12a1da61d31289d8b3ff3f">pa_stream_new</a> (<a class="el" href="context_8h.html#aff56e9b3dd442a88227da084bb5c380a">pa_context</a> *c, const char *name, const <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *ss, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map)</td></tr>
<tr class="memdesc:ab95a64207d12a1da61d31289d8b3ff3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, unconnected stream with the specified name and sample type.  <a href="#ab95a64207d12a1da61d31289d8b3ff3f">More...</a><br /></td></tr>
<tr class="separator:ab95a64207d12a1da61d31289d8b3ff3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd70e309f09679753499fa198713672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a5bd70e309f09679753499fa198713672">pa_stream_new_with_proplist</a> (<a class="el" href="context_8h.html#aff56e9b3dd442a88227da084bb5c380a">pa_context</a> *c, const char *name, const <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *ss, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map, <a class="el" href="proplist_8h.html#acdf756a6014b6fae3b358b2c934c3426">pa_proplist</a> *p)</td></tr>
<tr class="memdesc:a5bd70e309f09679753499fa198713672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, unconnected stream with the specified name and sample type, and specify the initial stream property list.  <a href="#a5bd70e309f09679753499fa198713672">More...</a><br /></td></tr>
<tr class="separator:a5bd70e309f09679753499fa198713672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf41f201c5e6ac94b7fcbc8626b6c933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#acf41f201c5e6ac94b7fcbc8626b6c933">pa_stream_new_extended</a> (<a class="el" href="context_8h.html#aff56e9b3dd442a88227da084bb5c380a">pa_context</a> *c, const char *name, <a class="el" href="structpa__format__info.html">pa_format_info</a> *const *formats, unsigned int n_formats, <a class="el" href="proplist_8h.html#acdf756a6014b6fae3b358b2c934c3426">pa_proplist</a> *p)</td></tr>
<tr class="memdesc:acf41f201c5e6ac94b7fcbc8626b6c933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, unconnected stream with the specified name, the set of formats this client can provide, and an initial list of properties.  <a href="#acf41f201c5e6ac94b7fcbc8626b6c933">More...</a><br /></td></tr>
<tr class="separator:acf41f201c5e6ac94b7fcbc8626b6c933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7780fa5438f31152b0a6aeae31b63264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a7780fa5438f31152b0a6aeae31b63264">pa_stream_unref</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:a7780fa5438f31152b0a6aeae31b63264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the reference counter by one.  <a href="#a7780fa5438f31152b0a6aeae31b63264">More...</a><br /></td></tr>
<tr class="separator:a7780fa5438f31152b0a6aeae31b63264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5564dc25593af14ede2ee855e198467a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a5564dc25593af14ede2ee855e198467a">pa_stream_ref</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:a5564dc25593af14ede2ee855e198467a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the reference counter by one.  <a href="#a5564dc25593af14ede2ee855e198467a">More...</a><br /></td></tr>
<tr class="separator:a5564dc25593af14ede2ee855e198467a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1da38d494d6485e35f0715f40dff0ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="def_8h.html#a112cf6dbe9ac5554fddc8da251797477">pa_stream_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ab1da38d494d6485e35f0715f40dff0ab">pa_stream_get_state</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p)</td></tr>
<tr class="memdesc:ab1da38d494d6485e35f0715f40dff0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current state of the stream.  <a href="#ab1da38d494d6485e35f0715f40dff0ab">More...</a><br /></td></tr>
<tr class="separator:ab1da38d494d6485e35f0715f40dff0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad995ede5ff0edefe068b6c7e53940e90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="context_8h.html#aff56e9b3dd442a88227da084bb5c380a">pa_context</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ad995ede5ff0edefe068b6c7e53940e90">pa_stream_get_context</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p)</td></tr>
<tr class="memdesc:ad995ede5ff0edefe068b6c7e53940e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context this stream is attached to.  <a href="#ad995ede5ff0edefe068b6c7e53940e90">More...</a><br /></td></tr>
<tr class="separator:ad995ede5ff0edefe068b6c7e53940e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa364d8b06db3fef32d2aa0d588f92706"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aa364d8b06db3fef32d2aa0d588f92706">pa_stream_get_index</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:aa364d8b06db3fef32d2aa0d588f92706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sink input resp. source output index this stream is identified in the server with.  <a href="#aa364d8b06db3fef32d2aa0d588f92706">More...</a><br /></td></tr>
<tr class="separator:aa364d8b06db3fef32d2aa0d588f92706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84f1dc4657cd2e2f52effffd4583963"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aa84f1dc4657cd2e2f52effffd4583963">pa_stream_get_device_index</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:aa84f1dc4657cd2e2f52effffd4583963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the sink or source this stream is connected to in the server.  <a href="#aa84f1dc4657cd2e2f52effffd4583963">More...</a><br /></td></tr>
<tr class="separator:aa84f1dc4657cd2e2f52effffd4583963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf568b636afbd00ff60e0c100595309e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#adf568b636afbd00ff60e0c100595309e">pa_stream_get_device_name</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:adf568b636afbd00ff60e0c100595309e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the sink or source this stream is connected to in the server.  <a href="#adf568b636afbd00ff60e0c100595309e">More...</a><br /></td></tr>
<tr class="separator:adf568b636afbd00ff60e0c100595309e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4234efbfc42b102edfc3f97789d257"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aaa4234efbfc42b102edfc3f97789d257">pa_stream_is_suspended</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:aaa4234efbfc42b102edfc3f97789d257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the sink or source this stream is connected to has been suspended.  <a href="#aaa4234efbfc42b102edfc3f97789d257">More...</a><br /></td></tr>
<tr class="separator:aaa4234efbfc42b102edfc3f97789d257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3247516f8c8a14e158cd20ab205d678"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ae3247516f8c8a14e158cd20ab205d678">pa_stream_is_corked</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:ae3247516f8c8a14e158cd20ab205d678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the this stream has been corked.  <a href="#ae3247516f8c8a14e158cd20ab205d678">More...</a><br /></td></tr>
<tr class="separator:ae3247516f8c8a14e158cd20ab205d678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9544f6677af133fbe81bf8a21eb489c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ab9544f6677af133fbe81bf8a21eb489c">pa_stream_connect_playback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, const char *dev, const <a class="el" href="structpa__buffer__attr.html">pa_buffer_attr</a> *attr, <a class="el" href="def_8h.html#a9328c83d983878efb0627b99d949a3cc">pa_stream_flags_t</a> flags, const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *volume, <a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *sync_stream)</td></tr>
<tr class="memdesc:ab9544f6677af133fbe81bf8a21eb489c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the stream to a sink.  <a href="#ab9544f6677af133fbe81bf8a21eb489c">More...</a><br /></td></tr>
<tr class="separator:ab9544f6677af133fbe81bf8a21eb489c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd34293aae8f170f572d1093c1bcdf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#abfd34293aae8f170f572d1093c1bcdf9">pa_stream_connect_record</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, const char *dev, const <a class="el" href="structpa__buffer__attr.html">pa_buffer_attr</a> *attr, <a class="el" href="def_8h.html#a9328c83d983878efb0627b99d949a3cc">pa_stream_flags_t</a> flags)</td></tr>
<tr class="memdesc:abfd34293aae8f170f572d1093c1bcdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the stream to a source.  <a href="#abfd34293aae8f170f572d1093c1bcdf9">More...</a><br /></td></tr>
<tr class="separator:abfd34293aae8f170f572d1093c1bcdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e0c83264f3935911e6b30e6f8ef2b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aa4e0c83264f3935911e6b30e6f8ef2b1">pa_stream_disconnect</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:aa4e0c83264f3935911e6b30e6f8ef2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect a stream from a source/sink.  <a href="#aa4e0c83264f3935911e6b30e6f8ef2b1">More...</a><br /></td></tr>
<tr class="separator:aa4e0c83264f3935911e6b30e6f8ef2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf50cfc4ea8897391941184d74d7dfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa">pa_stream_begin_write</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, void **data, size_t *nbytes)</td></tr>
<tr class="memdesc:a6cf50cfc4ea8897391941184d74d7dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare writing data to the server (for playback streams).  <a href="#a6cf50cfc4ea8897391941184d74d7dfa">More...</a><br /></td></tr>
<tr class="separator:a6cf50cfc4ea8897391941184d74d7dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295e8564cc2be4078f230d4a791a3ea2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a295e8564cc2be4078f230d4a791a3ea2">pa_stream_cancel_write</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p)</td></tr>
<tr class="memdesc:a295e8564cc2be4078f230d4a791a3ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the effect of <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a> dropping all data that has already been placed in the memory area returned by <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a>.  <a href="#a295e8564cc2be4078f230d4a791a3ea2">More...</a><br /></td></tr>
<tr class="separator:a295e8564cc2be4078f230d4a791a3ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc69dec0cc202fcc174125dc88dada7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7">pa_stream_write</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, const void *data, size_t nbytes, <a class="el" href="def_8h.html#a85c8c3063d8218304c041cb9f83ec431">pa_free_cb_t</a> free_cb, int64_t offset, <a class="el" href="def_8h.html#a3bd011cdb61caf568b544715b1b89def">pa_seek_mode_t</a> seek)</td></tr>
<tr class="memdesc:a4fc69dec0cc202fcc174125dc88dada7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some data to the server (for playback streams).  <a href="#a4fc69dec0cc202fcc174125dc88dada7">More...</a><br /></td></tr>
<tr class="separator:a4fc69dec0cc202fcc174125dc88dada7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8a546f5a955f3c301e7324ec557aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aaae8a546f5a955f3c301e7324ec557aa">pa_stream_write_ext_free</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, const void *data, size_t nbytes, <a class="el" href="def_8h.html#a85c8c3063d8218304c041cb9f83ec431">pa_free_cb_t</a> free_cb, void *free_cb_data, int64_t offset, <a class="el" href="def_8h.html#a3bd011cdb61caf568b544715b1b89def">pa_seek_mode_t</a> seek)</td></tr>
<tr class="memdesc:aaae8a546f5a955f3c301e7324ec557aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function does exactly the same as <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> with the difference that free_cb_data is passed to free_cb instead of data.  <a href="#aaae8a546f5a955f3c301e7324ec557aa">More...</a><br /></td></tr>
<tr class="separator:aaae8a546f5a955f3c301e7324ec557aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2838c449cde56e169224d7fe3d00824"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ac2838c449cde56e169224d7fe3d00824">pa_stream_peek</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, const void **data, size_t *nbytes)</td></tr>
<tr class="memdesc:ac2838c449cde56e169224d7fe3d00824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next fragment from the buffer (for recording streams).  <a href="#ac2838c449cde56e169224d7fe3d00824">More...</a><br /></td></tr>
<tr class="separator:ac2838c449cde56e169224d7fe3d00824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8a3e15fb63a5bb9cbba2d01a6538a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a2e8a3e15fb63a5bb9cbba2d01a6538a5">pa_stream_drop</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p)</td></tr>
<tr class="memdesc:a2e8a3e15fb63a5bb9cbba2d01a6538a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the current fragment on record streams.  <a href="#a2e8a3e15fb63a5bb9cbba2d01a6538a5">More...</a><br /></td></tr>
<tr class="separator:a2e8a3e15fb63a5bb9cbba2d01a6538a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63ccd1908b6deae1b2ca7be6fa759e7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ab63ccd1908b6deae1b2ca7be6fa759e7">pa_stream_writable_size</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p)</td></tr>
<tr class="memdesc:ab63ccd1908b6deae1b2ca7be6fa759e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that may be written using <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a>.  <a href="#ab63ccd1908b6deae1b2ca7be6fa759e7">More...</a><br /></td></tr>
<tr class="separator:ab63ccd1908b6deae1b2ca7be6fa759e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e5ff19aa36b90471c34badbdfdf345"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aa2e5ff19aa36b90471c34badbdfdf345">pa_stream_readable_size</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p)</td></tr>
<tr class="memdesc:aa2e5ff19aa36b90471c34badbdfdf345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that may be read using <a class="el" href="stream_8h.html#ac2838c449cde56e169224d7fe3d00824" title="Read the next fragment from the buffer (for recording streams). ">pa_stream_peek()</a>.  <a href="#aa2e5ff19aa36b90471c34badbdfdf345">More...</a><br /></td></tr>
<tr class="separator:aa2e5ff19aa36b90471c34badbdfdf345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d263f188073f244b3820f3f50db4ba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a8d263f188073f244b3820f3f50db4ba5">pa_stream_drain</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a8d263f188073f244b3820f3f50db4ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drain a playback stream.  <a href="#a8d263f188073f244b3820f3f50db4ba5">More...</a><br /></td></tr>
<tr class="separator:a8d263f188073f244b3820f3f50db4ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8300aa5136a223b14a5384f44564284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ac8300aa5136a223b14a5384f44564284">pa_stream_update_timing_info</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:ac8300aa5136a223b14a5384f44564284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a timing info structure update for a stream.  <a href="#ac8300aa5136a223b14a5384f44564284">More...</a><br /></td></tr>
<tr class="separator:ac8300aa5136a223b14a5384f44564284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295da6cbb032850600598d59fed2cc18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a295da6cbb032850600598d59fed2cc18">pa_stream_set_state_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, <a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a295da6cbb032850600598d59fed2cc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called whenever the state of the stream changes.  <a href="#a295da6cbb032850600598d59fed2cc18">More...</a><br /></td></tr>
<tr class="separator:a295da6cbb032850600598d59fed2cc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcc985c65964da290a0c2e1bf103175"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a2dcc985c65964da290a0c2e1bf103175">pa_stream_set_write_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#a47304c180a358523bed4020e38001d61">pa_stream_request_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a2dcc985c65964da290a0c2e1bf103175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called when new data may be written to the stream.  <a href="#a2dcc985c65964da290a0c2e1bf103175">More...</a><br /></td></tr>
<tr class="separator:a2dcc985c65964da290a0c2e1bf103175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9949b66e1aca2c1988f864e90f2ae4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ab9949b66e1aca2c1988f864e90f2ae4c">pa_stream_set_read_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#a47304c180a358523bed4020e38001d61">pa_stream_request_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:ab9949b66e1aca2c1988f864e90f2ae4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called when new data is available from the stream.  <a href="#ab9949b66e1aca2c1988f864e90f2ae4c">More...</a><br /></td></tr>
<tr class="separator:ab9949b66e1aca2c1988f864e90f2ae4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e07bc89d12aca66d2725a60cfdbdc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#af1e07bc89d12aca66d2725a60cfdbdc3">pa_stream_set_overflow_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:af1e07bc89d12aca66d2725a60cfdbdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called when a buffer overflow happens.  <a href="#af1e07bc89d12aca66d2725a60cfdbdc3">More...</a><br /></td></tr>
<tr class="separator:af1e07bc89d12aca66d2725a60cfdbdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573f7923840ae614f920daa8dff4f044"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a573f7923840ae614f920daa8dff4f044">pa_stream_get_underflow_index</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p)</td></tr>
<tr class="memdesc:a573f7923840ae614f920daa8dff4f044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return at what position the latest underflow occurred, or -1 if this information is not known (e.g. if no underflow has occurred, or server is older than 1.0).  <a href="#a573f7923840ae614f920daa8dff4f044">More...</a><br /></td></tr>
<tr class="separator:a573f7923840ae614f920daa8dff4f044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660b5a7096409f41ef52b8e0b7e96d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a660b5a7096409f41ef52b8e0b7e96d38">pa_stream_set_underflow_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a660b5a7096409f41ef52b8e0b7e96d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called when a buffer underflow happens.  <a href="#a660b5a7096409f41ef52b8e0b7e96d38">More...</a><br /></td></tr>
<tr class="separator:a660b5a7096409f41ef52b8e0b7e96d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa10d78431d934b07c690bc916f3daa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aaa10d78431d934b07c690bc916f3daa7">pa_stream_set_started_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:aaa10d78431d934b07c690bc916f3daa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called when a the server starts playback after an underrun or on initial startup.  <a href="#aaa10d78431d934b07c690bc916f3daa7">More...</a><br /></td></tr>
<tr class="separator:aaa10d78431d934b07c690bc916f3daa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e42c196273746ac523353a1dc5068dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a9e42c196273746ac523353a1dc5068dc">pa_stream_set_latency_update_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a9e42c196273746ac523353a1dc5068dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called whenever a latency information update happens.  <a href="#a9e42c196273746ac523353a1dc5068dc">More...</a><br /></td></tr>
<tr class="separator:a9e42c196273746ac523353a1dc5068dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6def5afeb0b2071f130bb373b3f114b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a6def5afeb0b2071f130bb373b3f114b8">pa_stream_set_moved_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a6def5afeb0b2071f130bb373b3f114b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called whenever the stream is moved to a different sink/source.  <a href="#a6def5afeb0b2071f130bb373b3f114b8">More...</a><br /></td></tr>
<tr class="separator:a6def5afeb0b2071f130bb373b3f114b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddaac3d3a921829c3080e7c8c15a21e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a4ddaac3d3a921829c3080e7c8c15a21e">pa_stream_set_suspended_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a4ddaac3d3a921829c3080e7c8c15a21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called whenever the sink/source this stream is connected to is suspended or resumed.  <a href="#a4ddaac3d3a921829c3080e7c8c15a21e">More...</a><br /></td></tr>
<tr class="separator:a4ddaac3d3a921829c3080e7c8c15a21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5690ed098466233860e632abfa61fe50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a5690ed098466233860e632abfa61fe50">pa_stream_set_event_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#a56d668892312b7e651cdf737336710e6">pa_stream_event_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a5690ed098466233860e632abfa61fe50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called whenever a meta/policy control event is received.  <a href="#a5690ed098466233860e632abfa61fe50">More...</a><br /></td></tr>
<tr class="separator:a5690ed098466233860e632abfa61fe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3d521e76540896442ef09cd12e3e2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a6a3d521e76540896442ef09cd12e3e2b">pa_stream_set_buffer_attr_callback</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, <a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a6a3d521e76540896442ef09cd12e3e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback function that is called whenever the buffer attributes on the server side change.  <a href="#a6a3d521e76540896442ef09cd12e3e2b">More...</a><br /></td></tr>
<tr class="separator:a6a3d521e76540896442ef09cd12e3e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e698233ac2d246646651955ab0ec7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a14e698233ac2d246646651955ab0ec7b">pa_stream_cork</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, int b, <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a14e698233ac2d246646651955ab0ec7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause (or resume) playback of this stream temporarily.  <a href="#a14e698233ac2d246646651955ab0ec7b">More...</a><br /></td></tr>
<tr class="separator:a14e698233ac2d246646651955ab0ec7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c524eb275d258b00c553409682409c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ac9c524eb275d258b00c553409682409c">pa_stream_flush</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:ac9c524eb275d258b00c553409682409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the playback or record buffer of this stream.  <a href="#ac9c524eb275d258b00c553409682409c">More...</a><br /></td></tr>
<tr class="separator:ac9c524eb275d258b00c553409682409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628650e49917cc9459a4a601a7f2a6fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a628650e49917cc9459a4a601a7f2a6fc">pa_stream_prebuf</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a628650e49917cc9459a4a601a7f2a6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reenable prebuffering if specified in the <a class="el" href="structpa__buffer__attr.html" title="Playback and record buffer metrics. ">pa_buffer_attr</a> structure.  <a href="#a628650e49917cc9459a4a601a7f2a6fc">More...</a><br /></td></tr>
<tr class="separator:a628650e49917cc9459a4a601a7f2a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17a3a9f6ee0403c4665f6f4ce02ca3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ae17a3a9f6ee0403c4665f6f4ce02ca3c">pa_stream_trigger</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:ae17a3a9f6ee0403c4665f6f4ce02ca3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request immediate start of playback on this stream.  <a href="#ae17a3a9f6ee0403c4665f6f4ce02ca3c">More...</a><br /></td></tr>
<tr class="separator:ae17a3a9f6ee0403c4665f6f4ce02ca3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f980de4097a4a815bcf143df68338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aac0f980de4097a4a815bcf143df68338">pa_stream_set_name</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, const char *name, <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:aac0f980de4097a4a815bcf143df68338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename the stream.  <a href="#aac0f980de4097a4a815bcf143df68338">More...</a><br /></td></tr>
<tr class="separator:aac0f980de4097a4a815bcf143df68338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1caba84c7a5c90efdbcaed31e9dfca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a9b1caba84c7a5c90efdbcaed31e9dfca">pa_stream_get_time</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, <a class="el" href="sample_8h.html#a885df3b973773f0dccbbec6bc6777f89">pa_usec_t</a> *r_usec)</td></tr>
<tr class="memdesc:a9b1caba84c7a5c90efdbcaed31e9dfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current playback/recording time.  <a href="#a9b1caba84c7a5c90efdbcaed31e9dfca">More...</a><br /></td></tr>
<tr class="separator:a9b1caba84c7a5c90efdbcaed31e9dfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa521efcc16fe2abf0f8461462432ac16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#aa521efcc16fe2abf0f8461462432ac16">pa_stream_get_latency</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, <a class="el" href="sample_8h.html#a885df3b973773f0dccbbec6bc6777f89">pa_usec_t</a> *r_usec, int *negative)</td></tr>
<tr class="memdesc:aa521efcc16fe2abf0f8461462432ac16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the total stream latency.  <a href="#aa521efcc16fe2abf0f8461462432ac16">More...</a><br /></td></tr>
<tr class="separator:aa521efcc16fe2abf0f8461462432ac16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090147751441a97e04a4acef1d6514cb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpa__timing__info.html">pa_timing_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a090147751441a97e04a4acef1d6514cb">pa_stream_get_timing_info</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:a090147751441a97e04a4acef1d6514cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the latest raw timing data structure.  <a href="#a090147751441a97e04a4acef1d6514cb">More...</a><br /></td></tr>
<tr class="separator:a090147751441a97e04a4acef1d6514cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274d745a41dc54cc6f946bed7bcd8a58"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a274d745a41dc54cc6f946bed7bcd8a58">pa_stream_get_sample_spec</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:a274d745a41dc54cc6f946bed7bcd8a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the stream's sample specification.  <a href="#a274d745a41dc54cc6f946bed7bcd8a58">More...</a><br /></td></tr>
<tr class="separator:a274d745a41dc54cc6f946bed7bcd8a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c92d45a14a876f187ff7bd8090826a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ac4c92d45a14a876f187ff7bd8090826a">pa_stream_get_channel_map</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:ac4c92d45a14a876f187ff7bd8090826a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the stream's channel map.  <a href="#ac4c92d45a14a876f187ff7bd8090826a">More...</a><br /></td></tr>
<tr class="separator:ac4c92d45a14a876f187ff7bd8090826a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb618b0412f929a8b0321cea49890dc3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#adb618b0412f929a8b0321cea49890dc3">pa_stream_get_format_info</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:adb618b0412f929a8b0321cea49890dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the stream's format.  <a href="#adb618b0412f929a8b0321cea49890dc3">More...</a><br /></td></tr>
<tr class="separator:adb618b0412f929a8b0321cea49890dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3c3e78eafb28cce3a16cef2b68a385"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpa__buffer__attr.html">pa_buffer_attr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a9a3c3e78eafb28cce3a16cef2b68a385">pa_stream_get_buffer_attr</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:a9a3c3e78eafb28cce3a16cef2b68a385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the per-stream server-side buffer metrics of the stream.  <a href="#a9a3c3e78eafb28cce3a16cef2b68a385">More...</a><br /></td></tr>
<tr class="separator:a9a3c3e78eafb28cce3a16cef2b68a385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af662224125a43b3e8ae25b3d3684c111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#af662224125a43b3e8ae25b3d3684c111">pa_stream_set_buffer_attr</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, const <a class="el" href="structpa__buffer__attr.html">pa_buffer_attr</a> *attr, <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:af662224125a43b3e8ae25b3d3684c111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the buffer metrics of the stream during playback.  <a href="#af662224125a43b3e8ae25b3d3684c111">More...</a><br /></td></tr>
<tr class="separator:af662224125a43b3e8ae25b3d3684c111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753f1475073632fd76c0e86699deea6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a753f1475073632fd76c0e86699deea6b">pa_stream_update_sample_rate</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, uint32_t rate, <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a753f1475073632fd76c0e86699deea6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the stream sampling rate during playback.  <a href="#a753f1475073632fd76c0e86699deea6b">More...</a><br /></td></tr>
<tr class="separator:a753f1475073632fd76c0e86699deea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe6f3fa88f06a6d2f7df23086dfcd19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a5fe6f3fa88f06a6d2f7df23086dfcd19">pa_stream_proplist_update</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, <a class="el" href="proplist_8h.html#a4b73cd513add16a26378a7941a9f1fd9">pa_update_mode_t</a> mode, <a class="el" href="proplist_8h.html#acdf756a6014b6fae3b358b2c934c3426">pa_proplist</a> *p, <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:a5fe6f3fa88f06a6d2f7df23086dfcd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the property list of the sink input/source output of this stream, adding new entries.  <a href="#a5fe6f3fa88f06a6d2f7df23086dfcd19">More...</a><br /></td></tr>
<tr class="separator:a5fe6f3fa88f06a6d2f7df23086dfcd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac113b1f9311a73b27dd894421deb4181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ac113b1f9311a73b27dd894421deb4181">pa_stream_proplist_remove</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, const char *const keys[], <a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a> cb, void *userdata)</td></tr>
<tr class="memdesc:ac113b1f9311a73b27dd894421deb4181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the property list of the sink input/source output of this stream, remove entries.  <a href="#ac113b1f9311a73b27dd894421deb4181">More...</a><br /></td></tr>
<tr class="separator:ac113b1f9311a73b27dd894421deb4181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b414edaa95ed08ed7e3b321a208d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#a2d4b414edaa95ed08ed7e3b321a208d0">pa_stream_set_monitor_stream</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, uint32_t sink_input_idx)</td></tr>
<tr class="memdesc:a2d4b414edaa95ed08ed7e3b321a208d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For record streams connected to a monitor source: monitor only a very specific sink input of the sink.  <a href="#a2d4b414edaa95ed08ed7e3b321a208d0">More...</a><br /></td></tr>
<tr class="separator:a2d4b414edaa95ed08ed7e3b321a208d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2526ff6c1eccea5ac7fda85aa7aa258"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html#ad2526ff6c1eccea5ac7fda85aa7aa258">pa_stream_get_monitor_stream</a> (<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s)</td></tr>
<tr class="memdesc:ad2526ff6c1eccea5ac7fda85aa7aa258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sink input index previously set with <a class="el" href="stream_8h.html#a2d4b414edaa95ed08ed7e3b321a208d0" title="For record streams connected to a monitor source: monitor only a very specific sink input of the sink...">pa_stream_set_monitor_stream()</a>.  <a href="#ad2526ff6c1eccea5ac7fda85aa7aa258">More...</a><br /></td></tr>
<tr class="separator:ad2526ff6c1eccea5ac7fda85aa7aa258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Audio streams for input, output and sample upload. </p>
<p>See also <a class="el" href="streams.html">Audio Streams</a> </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a960d798980692a2ff01e5a70553d4f29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> <a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An opaque stream for playback or recording. </p>

</div>
</div>
<a class="anchor" id="a56d668892312b7e651cdf737336710e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pa_stream_event_cb_t)(<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, const char *name, <a class="el" href="proplist_8h.html#acdf756a6014b6fae3b358b2c934c3426">pa_proplist</a> *pl, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback for asynchronous meta/policy event messages. </p>
<p>Well known event names are PA_STREAM_EVENT_REQUEST_CORK and PA_STREAM_EVENT_REQUEST_UNCORK. The set of defined events can be extended at any time. Also, server modules may introduce additional message types so make sure that your callback function ignores messages it doesn't know. </p><dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="ad2adcc8f27af8241005f3388e7081ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pa_stream_notify_cb_t)(<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic notification callback. </p>

</div>
</div>
<a class="anchor" id="a47304c180a358523bed4020e38001d61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pa_stream_request_cb_t)(<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *p, size_t nbytes, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic request callback. </p>

</div>
</div>
<a class="anchor" id="a4db8260c2273ec4ddd51e0ff9fa198b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pa_stream_success_cb_t)(<a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *s, int success, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic callback for operation completion. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6cf50cfc4ea8897391941184d74d7dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_begin_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare writing data to the server (for playback streams). </p>
<p>This function may be used to optimize the number of memory copies when doing playback ("zero-copy"). It is recommended to call this function before each call to <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a>.</p>
<p>Pass in the address to a pointer and an address of the number of bytes you want to write. On return the two values will contain a pointer where you can place the data to write and the maximum number of bytes you can write. <em>*nbytes</em> can be smaller or have the same value as you passed in. You need to be able to handle both cases. Accessing memory beyond the returned <em>*nbytes</em> value is invalid. Accessing the memory returned after the following <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> or <a class="el" href="stream_8h.html#a295e8564cc2be4078f230d4a791a3ea2" title="Reverses the effect of pa_stream_begin_write() dropping all data that has already been placed in the ...">pa_stream_cancel_write()</a> is invalid.</p>
<p>On invocation only <em>*nbytes</em> needs to be initialized, on return both *data and *nbytes will be valid. If you place (size_t) -1 in *nbytes on invocation the memory size will be chosen automatically (which is recommended to do). After placing your data in the memory area returned, call <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> with <em>data</em> set to an address within this memory area and an <em>nbytes</em> value that is smaller or equal to what was returned by this function to actually execute the write.</p>
<p>An invocation of <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> should follow "quickly" on <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a>. It is not recommended letting an unbounded amount of time pass after calling <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a> and before calling <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a>. If you want to cancel a previously called <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a> without calling <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> use <a class="el" href="stream_8h.html#a295e8564cc2be4078f230d4a791a3ea2" title="Reverses the effect of pa_stream_begin_write() dropping all data that has already been placed in the ...">pa_stream_cancel_write()</a>. Calling <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a> twice without calling <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> or <a class="el" href="stream_8h.html#a295e8564cc2be4078f230d4a791a3ea2" title="Reverses the effect of pa_stream_begin_write() dropping all data that has already been placed in the ...">pa_stream_cancel_write()</a> in between will return exactly the same <em>data</em> pointer and <em>nbytes</em> values. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="a295e8564cc2be4078f230d4a791a3ea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_cancel_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the effect of <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a> dropping all data that has already been placed in the memory area returned by <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a>. </p>
<p>Only valid to call if <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a> was called before and neither <a class="el" href="stream_8h.html#a295e8564cc2be4078f230d4a791a3ea2" title="Reverses the effect of pa_stream_begin_write() dropping all data that has already been placed in the ...">pa_stream_cancel_write()</a> nor <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> have been called yet. Accessing the memory previously returned by <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a> after this call is invalid. Any further explicit freeing of the memory area is not necessary. </p><dl class="section since"><dt>Since</dt><dd>0.9.16 </dd></dl>

</div>
</div>
<a class="anchor" id="ab9544f6677af133fbe81bf8a21eb489c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_connect_playback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__buffer__attr.html">pa_buffer_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="def_8h.html#a9328c83d983878efb0627b99d949a3cc">pa_stream_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__cvolume.html">pa_cvolume</a> *&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>sync_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect the stream to a sink. </p>
<p>It is strongly recommended to pass NULL in both <em>dev</em> and <em>volume</em> and to set neither PA_STREAM_START_MUTED nor PA_STREAM_START_UNMUTED &ndash; unless these options are directly dependent on user input or configuration.</p>
<p>If you follow this rule then the sound server will have the full flexibility to choose the device, volume and mute status automatically, based on server-side policies, heuristics and stored information from previous uses. Also the server may choose to reconfigure audio devices to make other sinks/sources or capabilities available to be able to accept the stream.</p>
<p>Before 0.9.20 it was not defined whether the <em>volume</em> parameter was interpreted relative to the sink's current volume or treated as an absolute device volume. Since 0.9.20 it is an absolute volume when the sink is in flat volume mode, and relative otherwise, thus making sure the volume passed here has always the same semantics as the volume passed to <a class="el" href="introspect_8h.html#a825ccd9e00765c0d397e2341086586ff" title="Set the volume of a sink input stream. ">pa_context_set_sink_input_volume()</a>. It is possible to figure out whether flat volume mode is in effect for a given sink by calling <a class="el" href="introspect_8h.html#a446ffde2b8adea89940adcba40be319c" title="Get information about a sink by its name. ">pa_context_get_sink_info_by_name()</a>.</p>
<p>Since 5.0, it's possible to specify a single-channel volume even if the stream has multiple channels. In that case the same volume is applied to all channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to connect to a sink </td></tr>
    <tr><td class="paramname">dev</td><td>Name of the sink to connect to, or NULL for default </td></tr>
    <tr><td class="paramname">attr</td><td>Buffering attributes, or NULL for default </td></tr>
    <tr><td class="paramname">flags</td><td>Additional flags, or 0 for default </td></tr>
    <tr><td class="paramname">volume</td><td>Initial volume, or NULL for default </td></tr>
    <tr><td class="paramname">sync_stream</td><td>Synchronize this stream with the specified one, or NULL for a standalone stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfd34293aae8f170f572d1093c1bcdf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_connect_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__buffer__attr.html">pa_buffer_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="def_8h.html#a9328c83d983878efb0627b99d949a3cc">pa_stream_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect the stream to a source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to connect to a source </td></tr>
    <tr><td class="paramname">dev</td><td>Name of the source to connect to, or NULL for default </td></tr>
    <tr><td class="paramname">attr</td><td>Buffer attributes, or NULL for default </td></tr>
    <tr><td class="paramname">flags</td><td>Additional flags, or 0 for default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14e698233ac2d246646651955ab0ec7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_cork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause (or resume) playback of this stream temporarily. </p>
<p>Available on both playback and recording streams. If <em>b</em> is 1 the stream is paused. If <em>b</em> is 0 the stream is resumed. The pause/resume operation is executed as quickly as possible. If a cork is very quickly followed by an uncork or the other way round, this might not actually have any effect on the stream that is output. You can use <a class="el" href="stream_8h.html#ae3247516f8c8a14e158cd20ab205d678" title="Return 1 if the this stream has been corked. ">pa_stream_is_corked()</a> to find out whether the stream is currently paused or not. Normally a stream will be created in uncorked state. If you pass PA_STREAM_START_CORKED as a flag when connecting the stream, it will be created in corked state. </p>

</div>
</div>
<a class="anchor" id="aa4e0c83264f3935911e6b30e6f8ef2b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect a stream from a source/sink. </p>

</div>
</div>
<a class="anchor" id="a8d263f188073f244b3820f3f50db4ba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_drain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drain a playback stream. </p>
<p>Use this for notification when the playback buffer is empty after playing all the audio in the buffer. Please note that only one drain operation per stream may be issued at a time. </p>

</div>
</div>
<a class="anchor" id="a2e8a3e15fb63a5bb9cbba2d01a6538a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_drop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the current fragment on record streams. </p>
<p>It is invalid to do this without first calling <a class="el" href="stream_8h.html#ac2838c449cde56e169224d7fe3d00824" title="Read the next fragment from the buffer (for recording streams). ">pa_stream_peek()</a>. </p>

</div>
</div>
<a class="anchor" id="ac9c524eb275d258b00c553409682409c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the playback or record buffer of this stream. </p>
<p>This discards any audio data in the buffer. Most of the time you're better off using the parameter <em>seek</em> of <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> instead of this function. </p>

</div>
</div>
<a class="anchor" id="a9a3c3e78eafb28cce3a16cef2b68a385"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpa__buffer__attr.html">pa_buffer_attr</a>* pa_stream_get_buffer_attr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the per-stream server-side buffer metrics of the stream. </p>
<p>Only valid after the stream has been connected successfully and if the server is at least PulseAudio 0.9. This will return the actual configured buffering metrics, which may differ from what was requested during <a class="el" href="stream_8h.html#abfd34293aae8f170f572d1093c1bcdf9" title="Connect the stream to a source. ">pa_stream_connect_record()</a> or <a class="el" href="stream_8h.html#ab9544f6677af133fbe81bf8a21eb489c" title="Connect the stream to a sink. ">pa_stream_connect_playback()</a>. This call will always return the actual per-stream server-side buffer metrics, regardless whether PA_STREAM_ADJUST_LATENCY is set or not. </p><dl class="section since"><dt>Since</dt><dd>0.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac4c92d45a14a876f187ff7bd8090826a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a>* pa_stream_get_channel_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the stream's channel map. </p>

</div>
</div>
<a class="anchor" id="ad995ede5ff0edefe068b6c7e53940e90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="context_8h.html#aff56e9b3dd442a88227da084bb5c380a">pa_context</a>* pa_stream_get_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the context this stream is attached to. </p>

</div>
</div>
<a class="anchor" id="aa84f1dc4657cd2e2f52effffd4583963"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pa_stream_get_device_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the sink or source this stream is connected to in the server. </p>
<p>This is useful with the introspection functions such as <a class="el" href="introspect_8h.html#ae886cd4bdc06fa98a61d15f818c33c9f" title="Get information about a sink by its index. ">pa_context_get_sink_info_by_index()</a> or <a class="el" href="introspect_8h.html#a55f2fbae1ce6b964e65c82c848280c06" title="Get information about a source by its index. ">pa_context_get_source_info_by_index()</a>.</p>
<p>Please note that streams may be moved between sinks/sources and thus it is recommended to use <a class="el" href="stream_8h.html#a6def5afeb0b2071f130bb373b3f114b8" title="Set the callback function that is called whenever the stream is moved to a different sink/source...">pa_stream_set_moved_callback()</a> to be notified about this. This function will return with -PA_ERR_NOTSUPPORTED when the server is older than 0.9.8. </p><dl class="section since"><dt>Since</dt><dd>0.9.8 </dd></dl>

</div>
</div>
<a class="anchor" id="adf568b636afbd00ff60e0c100595309e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pa_stream_get_device_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the sink or source this stream is connected to in the server. </p>
<p>This is useful with the introspection functions such as <a class="el" href="introspect_8h.html#a446ffde2b8adea89940adcba40be319c" title="Get information about a sink by its name. ">pa_context_get_sink_info_by_name()</a> or <a class="el" href="introspect_8h.html#a3904ba3fc9d83355cb84aab0d1cd3e91" title="Get information about a source by its name. ">pa_context_get_source_info_by_name()</a>.</p>
<p>Please note that streams may be moved between sinks/sources and thus it is recommended to use <a class="el" href="stream_8h.html#a6def5afeb0b2071f130bb373b3f114b8" title="Set the callback function that is called whenever the stream is moved to a different sink/source...">pa_stream_set_moved_callback()</a> to be notified about this. This function will return with -PA_ERR_NOTSUPPORTED when the server is older than 0.9.8. </p><dl class="section since"><dt>Since</dt><dd>0.9.8 </dd></dl>

</div>
</div>
<a class="anchor" id="adb618b0412f929a8b0321cea49890dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpa__format__info.html">pa_format_info</a>* pa_stream_get_format_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the stream's format. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa364d8b06db3fef32d2aa0d588f92706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pa_stream_get_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sink input resp. source output index this stream is identified in the server with. </p>
<p>This is useful with the introspection functions such as <a class="el" href="introspect_8h.html#aeca4a368510f46dac4313f498583e340" title="Get some information about a sink input by its index. ">pa_context_get_sink_input_info()</a> or <a class="el" href="introspect_8h.html#ae14eaf111465ea7c8aa2a9b746832b19" title="Get information about a source output by its index. ">pa_context_get_source_output_info()</a>. </p>

</div>
</div>
<a class="anchor" id="aa521efcc16fe2abf0f8461462432ac16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_get_latency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sample_8h.html#a885df3b973773f0dccbbec6bc6777f89">pa_usec_t</a> *&#160;</td>
          <td class="paramname"><em>r_usec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>negative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the total stream latency. </p>
<p>This function is based on <a class="el" href="stream_8h.html#a9b1caba84c7a5c90efdbcaed31e9dfca" title="Return the current playback/recording time. ">pa_stream_get_time()</a>.</p>
<p>The latency is stored in <em>*r_usec</em>. In case the stream is a monitoring stream the result can be negative, i.e. the captured samples are not yet played. In this case <em>*negative</em> is set to 1.</p>
<p>If no timing information has been received yet, this call will return -PA_ERR_NODATA. On success, it will return 0.</p>
<p>For more details see <a class="el" href="stream_8h.html#a090147751441a97e04a4acef1d6514cb" title="Return the latest raw timing data structure. ">pa_stream_get_timing_info()</a> and <a class="el" href="stream_8h.html#a9b1caba84c7a5c90efdbcaed31e9dfca" title="Return the current playback/recording time. ">pa_stream_get_time()</a>. </p>

</div>
</div>
<a class="anchor" id="ad2526ff6c1eccea5ac7fda85aa7aa258"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pa_stream_get_monitor_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sink input index previously set with <a class="el" href="stream_8h.html#a2d4b414edaa95ed08ed7e3b321a208d0" title="For record streams connected to a monitor source: monitor only a very specific sink input of the sink...">pa_stream_set_monitor_stream()</a>. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.11 </dd></dl>

</div>
</div>
<a class="anchor" id="a274d745a41dc54cc6f946bed7bcd8a58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a>* pa_stream_get_sample_spec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the stream's sample specification. </p>

</div>
</div>
<a class="anchor" id="ab1da38d494d6485e35f0715f40dff0ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="def_8h.html#a112cf6dbe9ac5554fddc8da251797477">pa_stream_state_t</a> pa_stream_get_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current state of the stream. </p>

</div>
</div>
<a class="anchor" id="a9b1caba84c7a5c90efdbcaed31e9dfca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_get_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sample_8h.html#a885df3b973773f0dccbbec6bc6777f89">pa_usec_t</a> *&#160;</td>
          <td class="paramname"><em>r_usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current playback/recording time. </p>
<p>This is based on the data in the timing info structure returned by <a class="el" href="stream_8h.html#a090147751441a97e04a4acef1d6514cb" title="Return the latest raw timing data structure. ">pa_stream_get_timing_info()</a>.</p>
<p>This function will usually only return new data if a timing info update has been received. Only if timing interpolation has been requested (PA_STREAM_INTERPOLATE_TIMING) the data from the last timing update is used for an estimation of the current playback/recording time based on the local time that passed since the timing info structure has been acquired.</p>
<p>The time value returned by this function is guaranteed to increase monotonically (the returned value is always greater or equal to the value returned by the last call). This behaviour can be disabled by using PA_STREAM_NOT_MONOTONIC. This may be desirable to better deal with bad estimations of transport latencies, but may have strange effects if the application is not able to deal with time going 'backwards'.</p>
<p>The time interpolator activated by PA_STREAM_INTERPOLATE_TIMING favours 'smooth' time graphs over accurate ones to improve the smoothness of UI operations that are tied to the audio clock. If accuracy is more important to you, you might need to estimate your timing based on the data from <a class="el" href="stream_8h.html#a090147751441a97e04a4acef1d6514cb" title="Return the latest raw timing data structure. ">pa_stream_get_timing_info()</a> yourself or not work with interpolated timing at all and instead always query the server side for the most up to date timing with <a class="el" href="stream_8h.html#ac8300aa5136a223b14a5384f44564284" title="Request a timing info structure update for a stream. ">pa_stream_update_timing_info()</a>.</p>
<p>If no timing information has been received yet this call will return -PA_ERR_NODATA. For more details see <a class="el" href="stream_8h.html#a090147751441a97e04a4acef1d6514cb" title="Return the latest raw timing data structure. ">pa_stream_get_timing_info()</a>. </p>

</div>
</div>
<a class="anchor" id="a090147751441a97e04a4acef1d6514cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpa__timing__info.html">pa_timing_info</a>* pa_stream_get_timing_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the latest raw timing data structure. </p>
<p>The returned pointer refers to an internal read-only instance of the timing structure. The user should make a copy of this structure if he wants to modify it. An in-place update to this data structure may be requested using <a class="el" href="stream_8h.html#ac8300aa5136a223b14a5384f44564284" title="Request a timing info structure update for a stream. ">pa_stream_update_timing_info()</a>.</p>
<p>If no timing information has been received before (i.e. by requesting <a class="el" href="stream_8h.html#ac8300aa5136a223b14a5384f44564284" title="Request a timing info structure update for a stream. ">pa_stream_update_timing_info()</a> or by using PA_STREAM_AUTO_TIMING_UPDATE), this function will fail with -PA_ERR_NODATA.</p>
<p>Please note that the write_index member field (and only this field) is updated on each <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> call, not just when a timing update has been received. </p>

</div>
</div>
<a class="anchor" id="a573f7923840ae614f920daa8dff4f044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t pa_stream_get_underflow_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return at what position the latest underflow occurred, or -1 if this information is not known (e.g. if no underflow has occurred, or server is older than 1.0). </p>
<p>Can be used inside the underflow callback to get information about the current underflow. (Only for playback streams) </p><dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ae3247516f8c8a14e158cd20ab205d678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_is_corked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return 1 if the this stream has been corked. </p>
<p>This will return 0 if not, and a negative value on error. </p><dl class="section since"><dt>Since</dt><dd>0.9.11 </dd></dl>

</div>
</div>
<a class="anchor" id="aaa4234efbfc42b102edfc3f97789d257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_is_suspended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return 1 if the sink or source this stream is connected to has been suspended. </p>
<p>This will return 0 if not, and a negative value on error. This function will return with -PA_ERR_NOTSUPPORTED when the server is older than 0.9.8. </p><dl class="section since"><dt>Since</dt><dd>0.9.8 </dd></dl>

</div>
</div>
<a class="anchor" id="ab95a64207d12a1da61d31289d8b3ff3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a>* pa_stream_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="context_8h.html#aff56e9b3dd442a88227da084bb5c380a">pa_context</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, unconnected stream with the specified name and sample type. </p>
<p>It is recommended to use <a class="el" href="stream_8h.html#a5bd70e309f09679753499fa198713672" title="Create a new, unconnected stream with the specified name and sample type, and specify the initial str...">pa_stream_new_with_proplist()</a> instead and specify some initial properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The context to create this stream in </td></tr>
    <tr><td class="paramname">name</td><td>A name for this stream </td></tr>
    <tr><td class="paramname">ss</td><td>The desired sample format </td></tr>
    <tr><td class="paramname">map</td><td>The desired channel map, or NULL for default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf41f201c5e6ac94b7fcbc8626b6c933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a>* pa_stream_new_extended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="context_8h.html#aff56e9b3dd442a88227da084bb5c380a">pa_context</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *const *&#160;</td>
          <td class="paramname"><em>formats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_formats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="proplist_8h.html#acdf756a6014b6fae3b358b2c934c3426">pa_proplist</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, unconnected stream with the specified name, the set of formats this client can provide, and an initial list of properties. </p>
<p>While connecting, the server will select the most appropriate format which the client must then provide. </p><dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The context to create this stream in </td></tr>
    <tr><td class="paramname">name</td><td>A name for this stream </td></tr>
    <tr><td class="paramname">formats</td><td>The list of formats that can be provided </td></tr>
    <tr><td class="paramname">n_formats</td><td>The number of formats being passed in </td></tr>
    <tr><td class="paramname">p</td><td>The initial property list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bd70e309f09679753499fa198713672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a>* pa_stream_new_with_proplist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="context_8h.html#aff56e9b3dd442a88227da084bb5c380a">pa_context</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="proplist_8h.html#acdf756a6014b6fae3b358b2c934c3426">pa_proplist</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, unconnected stream with the specified name and sample type, and specify the initial stream property list. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.11 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The context to create this stream in </td></tr>
    <tr><td class="paramname">name</td><td>A name for this stream </td></tr>
    <tr><td class="paramname">ss</td><td>The desired sample format </td></tr>
    <tr><td class="paramname">map</td><td>The desired channel map, or NULL for default </td></tr>
    <tr><td class="paramname">p</td><td>The initial property list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2838c449cde56e169224d7fe3d00824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next fragment from the buffer (for recording streams). </p>
<p>If there is data at the current read index, <em>data</em> will point to the actual data and <em>nbytes</em> will contain the size of the data in bytes (which can be less or more than a complete fragment).</p>
<p>If there is no data at the current read index, it means that either the buffer is empty or it contains a hole (that is, the write index is ahead of the read index but there's no data where the read index points at). If the buffer is empty, <em>data</em> will be NULL and <em>nbytes</em> will be 0. If there is a hole, <em>data</em> will be NULL and <em>nbytes</em> will contain the length of the hole.</p>
<p>Use <a class="el" href="stream_8h.html#a2e8a3e15fb63a5bb9cbba2d01a6538a5" title="Remove the current fragment on record streams. ">pa_stream_drop()</a> to actually remove the data from the buffer and move the read index forward. <a class="el" href="stream_8h.html#a2e8a3e15fb63a5bb9cbba2d01a6538a5" title="Remove the current fragment on record streams. ">pa_stream_drop()</a> should not be called if the buffer is empty, but it should be called if there is a hole. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The stream to use </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to pointer that will point to data </td></tr>
    <tr><td class="paramname">nbytes</td><td>The length of the data read in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a628650e49917cc9459a4a601a7f2a6fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_prebuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reenable prebuffering if specified in the <a class="el" href="structpa__buffer__attr.html" title="Playback and record buffer metrics. ">pa_buffer_attr</a> structure. </p>
<p>Available for playback streams only. </p>

</div>
</div>
<a class="anchor" id="ac113b1f9311a73b27dd894421deb4181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_proplist_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>keys</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the property list of the sink input/source output of this stream, remove entries. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.11 </dd></dl>

</div>
</div>
<a class="anchor" id="a5fe6f3fa88f06a6d2f7df23086dfcd19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_proplist_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="proplist_8h.html#a4b73cd513add16a26378a7941a9f1fd9">pa_update_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="proplist_8h.html#acdf756a6014b6fae3b358b2c934c3426">pa_proplist</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the property list of the sink input/source output of this stream, adding new entries. </p>
<p>Please note that it is highly recommended to set as many properties initially via <a class="el" href="stream_8h.html#a5bd70e309f09679753499fa198713672" title="Create a new, unconnected stream with the specified name and sample type, and specify the initial str...">pa_stream_new_with_proplist()</a> as possible instead a posteriori with this function, since that information may be used to route this stream to the right device. </p><dl class="section since"><dt>Since</dt><dd>0.9.11 </dd></dl>

</div>
</div>
<a class="anchor" id="aa2e5ff19aa36b90471c34badbdfdf345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pa_stream_readable_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes that may be read using <a class="el" href="stream_8h.html#ac2838c449cde56e169224d7fe3d00824" title="Read the next fragment from the buffer (for recording streams). ">pa_stream_peek()</a>. </p>

</div>
</div>
<a class="anchor" id="a5564dc25593af14ede2ee855e198467a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a>* pa_stream_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the reference counter by one. </p>

</div>
</div>
<a class="anchor" id="af662224125a43b3e8ae25b3d3684c111"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_set_buffer_attr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__buffer__attr.html">pa_buffer_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the buffer metrics of the stream during playback. </p>
<p>The server might have chosen different buffer metrics then requested. The selected metrics may be queried with <a class="el" href="stream_8h.html#a9a3c3e78eafb28cce3a16cef2b68a385" title="Return the per-stream server-side buffer metrics of the stream. ">pa_stream_get_buffer_attr()</a> as soon as the callback is called. Only valid after the stream has been connected successfully and if the server is at least PulseAudio 0.9.8. Please be aware of the slightly different semantics of the call depending whether PA_STREAM_ADJUST_LATENCY is set or not. </p><dl class="section since"><dt>Since</dt><dd>0.9.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a6a3d521e76540896442ef09cd12e3e2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_buffer_attr_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called whenever the buffer attributes on the server side change. </p>
<p>Please note that the buffer attributes can change when moving a stream to a different sink/source too, hence if you use this callback you should use <a class="el" href="stream_8h.html#a6def5afeb0b2071f130bb373b3f114b8" title="Set the callback function that is called whenever the stream is moved to a different sink/source...">pa_stream_set_moved_callback()</a> as well. </p><dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="a5690ed098466233860e632abfa61fe50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_event_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a56d668892312b7e651cdf737336710e6">pa_stream_event_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called whenever a meta/policy control event is received. </p>
<dl class="section since"><dt>Since</dt><dd>0.9.15 </dd></dl>

</div>
</div>
<a class="anchor" id="a9e42c196273746ac523353a1dc5068dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_latency_update_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called whenever a latency information update happens. </p>
<p>Useful on PA_STREAM_AUTO_TIMING_UPDATE streams only. </p>

</div>
</div>
<a class="anchor" id="a2d4b414edaa95ed08ed7e3b321a208d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_set_monitor_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sink_input_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For record streams connected to a monitor source: monitor only a very specific sink input of the sink. </p>
<p>This function needs to be called before <a class="el" href="stream_8h.html#abfd34293aae8f170f572d1093c1bcdf9" title="Connect the stream to a source. ">pa_stream_connect_record()</a> is called. </p><dl class="section since"><dt>Since</dt><dd>0.9.11 </dd></dl>

</div>
</div>
<a class="anchor" id="a6def5afeb0b2071f130bb373b3f114b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_moved_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called whenever the stream is moved to a different sink/source. </p>
<p>Use <a class="el" href="stream_8h.html#adf568b636afbd00ff60e0c100595309e" title="Return the name of the sink or source this stream is connected to in the server. ">pa_stream_get_device_name()</a> or <a class="el" href="stream_8h.html#aa84f1dc4657cd2e2f52effffd4583963" title="Return the index of the sink or source this stream is connected to in the server. ...">pa_stream_get_device_index()</a> to query the new sink/source. This notification is only generated when the server is at least 0.9.8. </p><dl class="section since"><dt>Since</dt><dd>0.9.8 </dd></dl>

</div>
</div>
<a class="anchor" id="aac0f980de4097a4a815bcf143df68338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_set_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename the stream. </p>

</div>
</div>
<a class="anchor" id="af1e07bc89d12aca66d2725a60cfdbdc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_overflow_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called when a buffer overflow happens. </p>
<p>(Only for playback streams) </p>

</div>
</div>
<a class="anchor" id="ab9949b66e1aca2c1988f864e90f2ae4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_read_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a47304c180a358523bed4020e38001d61">pa_stream_request_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called when new data is available from the stream. </p>

</div>
</div>
<a class="anchor" id="aaa10d78431d934b07c690bc916f3daa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_started_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called when a the server starts playback after an underrun or on initial startup. </p>
<p>This only informs that audio is flowing again, it is no indication that audio started to reach the speakers already. (Only for playback streams) </p><dl class="section since"><dt>Since</dt><dd>0.9.11 </dd></dl>

</div>
</div>
<a class="anchor" id="a295da6cbb032850600598d59fed2cc18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_state_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called whenever the state of the stream changes. </p>

</div>
</div>
<a class="anchor" id="a4ddaac3d3a921829c3080e7c8c15a21e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_suspended_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called whenever the sink/source this stream is connected to is suspended or resumed. </p>
<p>Use <a class="el" href="stream_8h.html#aaa4234efbfc42b102edfc3f97789d257" title="Return 1 if the sink or source this stream is connected to has been suspended. ">pa_stream_is_suspended()</a> to query the new suspend status. Please note that the suspend status might also change when the stream is moved between devices. Thus if you call this function you very likely want to call <a class="el" href="stream_8h.html#a6def5afeb0b2071f130bb373b3f114b8" title="Set the callback function that is called whenever the stream is moved to a different sink/source...">pa_stream_set_moved_callback()</a> too. This notification is only generated when the server is at least 0.9.8. </p><dl class="section since"><dt>Since</dt><dd>0.9.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a660b5a7096409f41ef52b8e0b7e96d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_underflow_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#ad2adcc8f27af8241005f3388e7081ccc">pa_stream_notify_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called when a buffer underflow happens. </p>
<p>(Only for playback streams) </p>

</div>
</div>
<a class="anchor" id="a2dcc985c65964da290a0c2e1bf103175"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_set_write_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a47304c180a358523bed4020e38001d61">pa_stream_request_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback function that is called when new data may be written to the stream. </p>

</div>
</div>
<a class="anchor" id="ae17a3a9f6ee0403c4665f6f4ce02ca3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request immediate start of playback on this stream. </p>
<p>This disables prebuffering temporarily if specified in the <a class="el" href="structpa__buffer__attr.html" title="Playback and record buffer metrics. ">pa_buffer_attr</a> structure. Available for playback streams only. </p>

</div>
</div>
<a class="anchor" id="a7780fa5438f31152b0a6aeae31b63264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_stream_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the reference counter by one. </p>

</div>
</div>
<a class="anchor" id="a753f1475073632fd76c0e86699deea6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_update_sample_rate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the stream sampling rate during playback. </p>
<p>You need to pass PA_STREAM_VARIABLE_RATE in the flags parameter of <a class="el" href="stream_8h.html#ab9544f6677af133fbe81bf8a21eb489c" title="Connect the stream to a sink. ">pa_stream_connect_playback()</a> if you plan to use this function. Only valid after the stream has been connected successfully and if the server is at least PulseAudio 0.9.8. </p><dl class="section since"><dt>Since</dt><dd>0.9.8 </dd></dl>

</div>
</div>
<a class="anchor" id="ac8300aa5136a223b14a5384f44564284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="operation_8h.html#a5614a07f2e7a129e4cb16596ed452a0c">pa_operation</a>* pa_stream_update_timing_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a4db8260c2273ec4ddd51e0ff9fa198b0">pa_stream_success_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a timing info structure update for a stream. </p>
<p>Use <a class="el" href="stream_8h.html#a090147751441a97e04a4acef1d6514cb" title="Return the latest raw timing data structure. ">pa_stream_get_timing_info()</a> to get access to the raw timing data, or <a class="el" href="stream_8h.html#a9b1caba84c7a5c90efdbcaed31e9dfca" title="Return the current playback/recording time. ">pa_stream_get_time()</a> or <a class="el" href="stream_8h.html#aa521efcc16fe2abf0f8461462432ac16" title="Determine the total stream latency. ">pa_stream_get_latency()</a> to get cleaned up values. </p>

</div>
</div>
<a class="anchor" id="ab63ccd1908b6deae1b2ca7be6fa759e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pa_stream_writable_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes that may be written using <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a>. </p>

</div>
</div>
<a class="anchor" id="a4fc69dec0cc202fcc174125dc88dada7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="def_8h.html#a85c8c3063d8218304c041cb9f83ec431">pa_free_cb_t</a>&#160;</td>
          <td class="paramname"><em>free_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="def_8h.html#a3bd011cdb61caf568b544715b1b89def">pa_seek_mode_t</a>&#160;</td>
          <td class="paramname"><em>seek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write some data to the server (for playback streams). </p>
<p>If <em>free_cb</em> is non-NULL this routine is called when all data has been written out. An internal reference to the specified data is kept, the data is not copied. If NULL, the data is copied into an internal buffer.</p>
<p>The client may freely seek around in the output buffer. For most applications it is typical to pass 0 and PA_SEEK_RELATIVE as values for the arguments <em>offset</em> and <em>seek</em>. After the write call succeeded the write index will be at the position after where this chunk of data has been written to.</p>
<p>As an optimization for avoiding needless memory copies you may call <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a> before this call and then place your audio data directly in the memory area returned by that call. Then, pass a pointer to that memory area to <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a>. After the invocation of <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> the memory area may no longer be accessed. Any further explicit freeing of the memory area is not necessary. It is OK to write the memory area returned by <a class="el" href="stream_8h.html#a6cf50cfc4ea8897391941184d74d7dfa" title="Prepare writing data to the server (for playback streams). ">pa_stream_begin_write()</a> only partially with this call, skipping bytes both at the end and at the beginning of the reserved memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The stream to use </td></tr>
    <tr><td class="paramname">data</td><td>The data to write </td></tr>
    <tr><td class="paramname">nbytes</td><td>The length of the data to write in bytes </td></tr>
    <tr><td class="paramname">free_cb</td><td>A cleanup routine for the data or NULL to request an internal copy </td></tr>
    <tr><td class="paramname">offset</td><td>Offset for seeking, must be 0 for upload streams </td></tr>
    <tr><td class="paramname">seek</td><td>Seek mode, must be PA_SEEK_RELATIVE for upload streams </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaae8a546f5a955f3c301e7324ec557aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_stream_write_ext_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stream_8h.html#a960d798980692a2ff01e5a70553d4f29">pa_stream</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="def_8h.html#a85c8c3063d8218304c041cb9f83ec431">pa_free_cb_t</a>&#160;</td>
          <td class="paramname"><em>free_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>free_cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="def_8h.html#a3bd011cdb61caf568b544715b1b89def">pa_seek_mode_t</a>&#160;</td>
          <td class="paramname"><em>seek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function does exactly the same as <a class="el" href="stream_8h.html#a4fc69dec0cc202fcc174125dc88dada7" title="Write some data to the server (for playback streams). ">pa_stream_write()</a> with the difference that free_cb_data is passed to free_cb instead of data. </p>
<dl class="section since"><dt>Since</dt><dd>6.0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The stream to use </td></tr>
    <tr><td class="paramname">data</td><td>The data to write </td></tr>
    <tr><td class="paramname">nbytes</td><td>The length of the data to write in bytes </td></tr>
    <tr><td class="paramname">free_cb</td><td>A cleanup routine for the data or NULL to request an internal copy </td></tr>
    <tr><td class="paramname">free_cb_data</td><td>Argument passed to free_cb function </td></tr>
    <tr><td class="paramname">offset</td><td>Offset for seeking, must be 0 for upload streams </td></tr>
    <tr><td class="paramname">seek</td><td>Seek mode, must be PA_SEEK_RELATIVE for upload streams </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_ec5b0a79aff2db41fe5d1b9326f09c28.html">pulse</a></li><li class="navelem"><a class="el" href="stream_8h.html">stream.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
