<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PulseAudio: format.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PulseAudio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('format_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">format.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility functions for handling a stream or sink format.  
<a href="#details">More...</a></p>

<p><a href="format_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpa__format__info.html">pa_format_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the format of data provided in a stream or processed by a sink.  <a href="structpa__format__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9d03b1f626df546dd2f281a561853fe3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a9d03b1f626df546dd2f281a561853fe3">PA_FORMAT_INFO_SNPRINT_MAX</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:a9d03b1f626df546dd2f281a561853fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum required string length for <a class="el" href="format_8h.html#acebcc293f5e695a6c171d94e2d1f17a3" title="Return a human-readable string representing the given format. ">pa_format_info_snprint()</a>.  <a href="#a9d03b1f626df546dd2f281a561853fe3">More...</a><br /></td></tr>
<tr class="separator:a9d03b1f626df546dd2f281a561853fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a078cbc9162779d7ea206b0546508a71b"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652">pa_encoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a078cbc9162779d7ea206b0546508a71b">pa_encoding_t</a></td></tr>
<tr class="memdesc:a078cbc9162779d7ea206b0546508a71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of encoding used in a stream or accepted by a sink.  <a href="#a078cbc9162779d7ea206b0546508a71b">More...</a><br /></td></tr>
<tr class="separator:a078cbc9162779d7ea206b0546508a71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc90e3d37d0b6af1ab8deb6234ee8e5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpa__format__info.html">pa_format_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#aedc90e3d37d0b6af1ab8deb6234ee8e5">pa_format_info</a></td></tr>
<tr class="memdesc:aedc90e3d37d0b6af1ab8deb6234ee8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the format of data provided in a stream or processed by a sink.  <a href="#aedc90e3d37d0b6af1ab8deb6234ee8e5">More...</a><br /></td></tr>
<tr class="separator:aedc90e3d37d0b6af1ab8deb6234ee8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa698bc6691e7b7f7f0376cdb10f83dcf"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007">pa_prop_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#aa698bc6691e7b7f7f0376cdb10f83dcf">pa_prop_type_t</a></td></tr>
<tr class="memdesc:aa698bc6691e7b7f7f0376cdb10f83dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of value type of a property on a <a class="el" href="structpa__format__info.html">pa_format_info</a>.  <a href="#aa698bc6691e7b7f7f0376cdb10f83dcf">More...</a><br /></td></tr>
<tr class="separator:aa698bc6691e7b7f7f0376cdb10f83dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a708ed76801eb84544075e21fe8a07652"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652">pa_encoding</a> { <br />
&#160;&#160;<a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652a1314110ee09c543c975b3ebdffe5bf70">PA_ENCODING_ANY</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652af5b3680520cee5f542b4d3d1b1c4e71f">PA_ENCODING_PCM</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652af570614498d7843f30f2860d14a8318a">PA_ENCODING_AC3_IEC61937</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652a080fa22cf987bdc4b64328984693d9ba">PA_ENCODING_EAC3_IEC61937</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652a37ea55639a90b284526d4c29c86737e5">PA_ENCODING_MPEG_IEC61937</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652ad97283df564ca82862896059fa5877ce">PA_ENCODING_DTS_IEC61937</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652a96bfd1eb3dea46d8f05abac6cf060aec">PA_ENCODING_MPEG2_AAC_IEC61937</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652a6183eb06c06e2d708b7423da49824bd4">PA_ENCODING_MAX</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652a1f9111d9e6ce5a7d631a9cf256cded52">PA_ENCODING_INVALID</a> = -1
<br />
 }</td></tr>
<tr class="memdesc:a708ed76801eb84544075e21fe8a07652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of encoding used in a stream or accepted by a sink.  <a href="format_8h.html#a708ed76801eb84544075e21fe8a07652">More...</a><br /></td></tr>
<tr class="separator:a708ed76801eb84544075e21fe8a07652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86db8f0013a38e9a0f18ed69859a4007"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007">pa_prop_type_t</a> { <br />
&#160;&#160;<a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007a10142fbf5a15bbdac6153afc1f3965bf">PA_PROP_TYPE_INT</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007a5b7b6fc0c6064e1653109e2e239606f8">PA_PROP_TYPE_INT_RANGE</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007ad045693657b6cbdf25a4f562b1a4b621">PA_PROP_TYPE_INT_ARRAY</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007a04e9b28bc24156fec65d0208eeffe35e">PA_PROP_TYPE_STRING</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007a4ab87daa27459bbed1cead84800135c8">PA_PROP_TYPE_STRING_ARRAY</a>, 
<br />
&#160;&#160;<a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007adf3b133ae062ed88366c26d3645027c7">PA_PROP_TYPE_INVALID</a> = -1
<br />
 }</td></tr>
<tr class="memdesc:a86db8f0013a38e9a0f18ed69859a4007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of value type of a property on a <a class="el" href="structpa__format__info.html">pa_format_info</a>.  <a href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007">More...</a><br /></td></tr>
<tr class="separator:a86db8f0013a38e9a0f18ed69859a4007"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab26d3d38076ec1253877b56bb6e4c5a1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#ab26d3d38076ec1253877b56bb6e4c5a1">pa_encoding_to_string</a> (<a class="el" href="format_8h.html#a078cbc9162779d7ea206b0546508a71b">pa_encoding_t</a> e) <a class="el" href="gccmacro_8h.html#a318a98dce3b37977670c87a74c173b16">PA_GCC_CONST</a></td></tr>
<tr class="memdesc:ab26d3d38076ec1253877b56bb6e4c5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a printable string representing the given encoding type.  <a href="#ab26d3d38076ec1253877b56bb6e4c5a1">More...</a><br /></td></tr>
<tr class="separator:ab26d3d38076ec1253877b56bb6e4c5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96df235255893807a779cf986a322ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="format_8h.html#a078cbc9162779d7ea206b0546508a71b">pa_encoding_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#ad96df235255893807a779cf986a322ba">pa_encoding_from_string</a> (const char *encoding)</td></tr>
<tr class="memdesc:ad96df235255893807a779cf986a322ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string of the form returned by <em><a class="el" href="format_8h.html#ab26d3d38076ec1253877b56bb6e4c5a1" title="Returns a printable string representing the given encoding type. ">pa_encoding_to_string()</a></em> back to a <em>pa_encoding_t</em>.  <a href="#ad96df235255893807a779cf986a322ba">More...</a><br /></td></tr>
<tr class="separator:ad96df235255893807a779cf986a322ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656b51bb7c82883e4cad92b134625942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a656b51bb7c82883e4cad92b134625942">pa_format_info_new</a> (void)</td></tr>
<tr class="memdesc:a656b51bb7c82883e4cad92b134625942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <em><a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a></em> structure.  <a href="#a656b51bb7c82883e4cad92b134625942">More...</a><br /></td></tr>
<tr class="separator:a656b51bb7c82883e4cad92b134625942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb74d9b96e4e7f2bf446ccb59fe795b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#adcb74d9b96e4e7f2bf446ccb59fe795b">pa_format_info_copy</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *src)</td></tr>
<tr class="memdesc:adcb74d9b96e4e7f2bf446ccb59fe795b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <em><a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a></em> struct and representing the same format as <em>src</em>.  <a href="#adcb74d9b96e4e7f2bf446ccb59fe795b">More...</a><br /></td></tr>
<tr class="separator:adcb74d9b96e4e7f2bf446ccb59fe795b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a85d0c897cda925339194a6afbf4f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#ad4a85d0c897cda925339194a6afbf4f3">pa_format_info_free</a> (<a class="el" href="structpa__format__info.html">pa_format_info</a> *f)</td></tr>
<tr class="memdesc:ad4a85d0c897cda925339194a6afbf4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <em><a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a></em> structure.  <a href="#ad4a85d0c897cda925339194a6afbf4f3">More...</a><br /></td></tr>
<tr class="separator:ad4a85d0c897cda925339194a6afbf4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efd301cfd24b37737c6a2e2b47c9261"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a9efd301cfd24b37737c6a2e2b47c9261">pa_format_info_valid</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *f)</td></tr>
<tr class="memdesc:a9efd301cfd24b37737c6a2e2b47c9261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero when the format info structure is valid.  <a href="#a9efd301cfd24b37737c6a2e2b47c9261">More...</a><br /></td></tr>
<tr class="separator:a9efd301cfd24b37737c6a2e2b47c9261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c48d16d0851791265bdb33ce81b749b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a8c48d16d0851791265bdb33ce81b749b">pa_format_info_is_pcm</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *f)</td></tr>
<tr class="memdesc:a8c48d16d0851791265bdb33ce81b749b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero when the format info structure represents a PCM (i.e. uncompressed data) format.  <a href="#a8c48d16d0851791265bdb33ce81b749b">More...</a><br /></td></tr>
<tr class="separator:a8c48d16d0851791265bdb33ce81b749b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d871a0d9c0624d17a6fe12be0a548a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a71d871a0d9c0624d17a6fe12be0a548a">pa_format_info_is_compatible</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *first, const <a class="el" href="structpa__format__info.html">pa_format_info</a> *second)</td></tr>
<tr class="memdesc:a71d871a0d9c0624d17a6fe12be0a548a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the format represented by <em>first</em> is a subset of the format represented by <em>second</em>.  <a href="#a71d871a0d9c0624d17a6fe12be0a548a">More...</a><br /></td></tr>
<tr class="separator:a71d871a0d9c0624d17a6fe12be0a548a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebcc293f5e695a6c171d94e2d1f17a3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#acebcc293f5e695a6c171d94e2d1f17a3">pa_format_info_snprint</a> (char *s, size_t l, const <a class="el" href="structpa__format__info.html">pa_format_info</a> *f)</td></tr>
<tr class="memdesc:acebcc293f5e695a6c171d94e2d1f17a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable string representing the given format.  <a href="#acebcc293f5e695a6c171d94e2d1f17a3">More...</a><br /></td></tr>
<tr class="separator:acebcc293f5e695a6c171d94e2d1f17a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8df9952b866161e257807dfe5da4357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#ab8df9952b866161e257807dfe5da4357">pa_format_info_from_string</a> (const char *str)</td></tr>
<tr class="memdesc:ab8df9952b866161e257807dfe5da4357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a human-readable string of the form generated by <em><a class="el" href="format_8h.html#acebcc293f5e695a6c171d94e2d1f17a3" title="Return a human-readable string representing the given format. ">pa_format_info_snprint()</a></em> into a <a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a> structure.  <a href="#ab8df9952b866161e257807dfe5da4357">More...</a><br /></td></tr>
<tr class="separator:ab8df9952b866161e257807dfe5da4357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfd380549e94849b9bd29d43d62b593"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a1cfd380549e94849b9bd29d43d62b593">pa_format_info_from_sample_spec</a> (const <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *ss, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map)</td></tr>
<tr class="memdesc:a1cfd380549e94849b9bd29d43d62b593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to take a <em><a class="el" href="structpa__sample__spec.html" title="A sample format and attribute specification. ">pa_sample_spec</a></em> and generate the corresponding <em><a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a></em>.  <a href="#a1cfd380549e94849b9bd29d43d62b593">More...</a><br /></td></tr>
<tr class="separator:a1cfd380549e94849b9bd29d43d62b593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092e9e20e51cd2b3b72acccc7d10ef15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a092e9e20e51cd2b3b72acccc7d10ef15">pa_format_info_to_sample_spec</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *f, <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *ss, <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map)</td></tr>
<tr class="memdesc:a092e9e20e51cd2b3b72acccc7d10ef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to generate a <em><a class="el" href="structpa__sample__spec.html" title="A sample format and attribute specification. ">pa_sample_spec</a></em> and <em><a class="el" href="structpa__channel__map.html" title="A channel map which can be used to attach labels to specific channels of a stream. ">pa_channel_map</a></em> corresponding to a given <em><a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a></em>.  <a href="#a092e9e20e51cd2b3b72acccc7d10ef15">More...</a><br /></td></tr>
<tr class="separator:a092e9e20e51cd2b3b72acccc7d10ef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87728336c103aaac4c5e76d2c65f4cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007">pa_prop_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a87728336c103aaac4c5e76d2c65f4cce">pa_format_info_get_prop_type</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key)</td></tr>
<tr class="memdesc:a87728336c103aaac4c5e76d2c65f4cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of property <em>key</em> in a given <a class="el" href="structpa__format__info.html">pa_format_info</a>.  <a href="#a87728336c103aaac4c5e76d2c65f4cce">More...</a><br /></td></tr>
<tr class="separator:a87728336c103aaac4c5e76d2c65f4cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385d73fe57a2c2dfd28e9eca48f6c408"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a385d73fe57a2c2dfd28e9eca48f6c408">pa_format_info_get_prop_int</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key, int *v)</td></tr>
<tr class="memdesc:a385d73fe57a2c2dfd28e9eca48f6c408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an integer property from the given format info.  <a href="#a385d73fe57a2c2dfd28e9eca48f6c408">More...</a><br /></td></tr>
<tr class="separator:a385d73fe57a2c2dfd28e9eca48f6c408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e6eaecf82ee84f084b7654d938b9cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#ab8e6eaecf82ee84f084b7654d938b9cb">pa_format_info_get_prop_int_range</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key, int *min, int *max)</td></tr>
<tr class="memdesc:ab8e6eaecf82ee84f084b7654d938b9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an integer range property from the given format info.  <a href="#ab8e6eaecf82ee84f084b7654d938b9cb">More...</a><br /></td></tr>
<tr class="separator:ab8e6eaecf82ee84f084b7654d938b9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662935ca585b97d292336e638c2d2bb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a662935ca585b97d292336e638c2d2bb3">pa_format_info_get_prop_int_array</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key, int **values, int *n_values)</td></tr>
<tr class="memdesc:a662935ca585b97d292336e638c2d2bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an integer array property from the given format info.  <a href="#a662935ca585b97d292336e638c2d2bb3">More...</a><br /></td></tr>
<tr class="separator:a662935ca585b97d292336e638c2d2bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb07a605cdfae5ada7918e01aa0872c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a8bb07a605cdfae5ada7918e01aa0872c">pa_format_info_get_prop_string</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key, char **v)</td></tr>
<tr class="memdesc:a8bb07a605cdfae5ada7918e01aa0872c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string property from the given format info.  <a href="#a8bb07a605cdfae5ada7918e01aa0872c">More...</a><br /></td></tr>
<tr class="separator:a8bb07a605cdfae5ada7918e01aa0872c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c50248324fd57eb989ca898a5618fbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a1c50248324fd57eb989ca898a5618fbe">pa_format_info_get_prop_string_array</a> (const <a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key, char ***values, int *n_values)</td></tr>
<tr class="memdesc:a1c50248324fd57eb989ca898a5618fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string array property from the given format info.  <a href="#a1c50248324fd57eb989ca898a5618fbe">More...</a><br /></td></tr>
<tr class="separator:a1c50248324fd57eb989ca898a5618fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6c84b0e37e33cae25efd059d222d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a4e6c84b0e37e33cae25efd059d222d5c">pa_format_info_free_string_array</a> (char **values, int n_values)</td></tr>
<tr class="memdesc:a4e6c84b0e37e33cae25efd059d222d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a string array returned by <a class="el" href="format_8h.html#a1c50248324fd57eb989ca898a5618fbe">pa_format_info_get_prop_string_array</a>.  <a href="#a4e6c84b0e37e33cae25efd059d222d5c">More...</a><br /></td></tr>
<tr class="separator:a4e6c84b0e37e33cae25efd059d222d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69567649133e4907c6a25e7baaa95d29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a69567649133e4907c6a25e7baaa95d29">pa_format_info_set_prop_int</a> (<a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key, int value)</td></tr>
<tr class="memdesc:a69567649133e4907c6a25e7baaa95d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an integer property on the given format info.  <a href="#a69567649133e4907c6a25e7baaa95d29">More...</a><br /></td></tr>
<tr class="separator:a69567649133e4907c6a25e7baaa95d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422a3d83da63a6e778f1a40bc3540667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a422a3d83da63a6e778f1a40bc3540667">pa_format_info_set_prop_int_array</a> (<a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key, const int *values, int n_values)</td></tr>
<tr class="memdesc:a422a3d83da63a6e778f1a40bc3540667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a property with a list of integer values on the given format info.  <a href="#a422a3d83da63a6e778f1a40bc3540667">More...</a><br /></td></tr>
<tr class="separator:a422a3d83da63a6e778f1a40bc3540667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faf1af2d146f848d1e31f276d4901c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a4faf1af2d146f848d1e31f276d4901c8">pa_format_info_set_prop_int_range</a> (<a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key, int min, int max)</td></tr>
<tr class="memdesc:a4faf1af2d146f848d1e31f276d4901c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a property which can have any value in a given integer range on the given format info.  <a href="#a4faf1af2d146f848d1e31f276d4901c8">More...</a><br /></td></tr>
<tr class="separator:a4faf1af2d146f848d1e31f276d4901c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0ad5ff976e2e3347b3bb98b0748b7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a3c0ad5ff976e2e3347b3bb98b0748b7a">pa_format_info_set_prop_string</a> (<a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key, const char *value)</td></tr>
<tr class="memdesc:a3c0ad5ff976e2e3347b3bb98b0748b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a string property on the given format info.  <a href="#a3c0ad5ff976e2e3347b3bb98b0748b7a">More...</a><br /></td></tr>
<tr class="separator:a3c0ad5ff976e2e3347b3bb98b0748b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae53ecf0d5b56a63aead1ff56f1cb25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a5ae53ecf0d5b56a63aead1ff56f1cb25">pa_format_info_set_prop_string_array</a> (<a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const char *key, const char **values, int n_values)</td></tr>
<tr class="memdesc:a5ae53ecf0d5b56a63aead1ff56f1cb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a property with a list of string values on the given format info.  <a href="#a5ae53ecf0d5b56a63aead1ff56f1cb25">More...</a><br /></td></tr>
<tr class="separator:a5ae53ecf0d5b56a63aead1ff56f1cb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e43baade49ac428880361b10d66d08e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a6e43baade49ac428880361b10d66d08e">pa_format_info_set_sample_format</a> (<a class="el" href="structpa__format__info.html">pa_format_info</a> *f, <a class="el" href="sample_8h.html#a41051ceaa5cfbe60c9b176deb7bfed0e">pa_sample_format_t</a> sf)</td></tr>
<tr class="memdesc:a6e43baade49ac428880361b10d66d08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to set the sample format as a property on the given format.  <a href="#a6e43baade49ac428880361b10d66d08e">More...</a><br /></td></tr>
<tr class="separator:a6e43baade49ac428880361b10d66d08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cdeda2c082cf6a006b0b08102268c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a01cdeda2c082cf6a006b0b08102268c2">pa_format_info_set_rate</a> (<a class="el" href="structpa__format__info.html">pa_format_info</a> *f, int rate)</td></tr>
<tr class="memdesc:a01cdeda2c082cf6a006b0b08102268c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to set the sampling rate as a property on the given format.  <a href="#a01cdeda2c082cf6a006b0b08102268c2">More...</a><br /></td></tr>
<tr class="separator:a01cdeda2c082cf6a006b0b08102268c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6238546c60f370e8171b274feac7cb70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a6238546c60f370e8171b274feac7cb70">pa_format_info_set_channels</a> (<a class="el" href="structpa__format__info.html">pa_format_info</a> *f, int channels)</td></tr>
<tr class="memdesc:a6238546c60f370e8171b274feac7cb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to set the number of channels as a property on the given format.  <a href="#a6238546c60f370e8171b274feac7cb70">More...</a><br /></td></tr>
<tr class="separator:a6238546c60f370e8171b274feac7cb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6894e4e8bbb8ac23928f24d8d4b05c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="format_8h.html#a2e6894e4e8bbb8ac23928f24d8d4b05c">pa_format_info_set_channel_map</a> (<a class="el" href="structpa__format__info.html">pa_format_info</a> *f, const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *map)</td></tr>
<tr class="memdesc:a2e6894e4e8bbb8ac23928f24d8d4b05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to set the channel map as a property on the given format.  <a href="#a2e6894e4e8bbb8ac23928f24d8d4b05c">More...</a><br /></td></tr>
<tr class="separator:a2e6894e4e8bbb8ac23928f24d8d4b05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility functions for handling a stream or sink format. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a9d03b1f626df546dd2f281a561853fe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PA_FORMAT_INFO_SNPRINT_MAX&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum required string length for <a class="el" href="format_8h.html#acebcc293f5e695a6c171d94e2d1f17a3" title="Return a human-readable string representing the given format. ">pa_format_info_snprint()</a>. </p>
<p>Please note that this value can change with any release without warning and without being considered API or ABI breakage. You should not use this definition anywhere where it might become part of an ABI. </p><dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a078cbc9162779d7ea206b0546508a71b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652">pa_encoding</a>  <a class="el" href="format_8h.html#a078cbc9162779d7ea206b0546508a71b">pa_encoding_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the type of encoding used in a stream or accepted by a sink. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aedc90e3d37d0b6af1ab8deb6234ee8e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structpa__format__info.html">pa_format_info</a>  <a class="el" href="structpa__format__info.html">pa_format_info</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the format of data provided in a stream or processed by a sink. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa698bc6691e7b7f7f0376cdb10f83dcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007">pa_prop_type_t</a>  <a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007">pa_prop_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the type of value type of a property on a <a class="el" href="structpa__format__info.html">pa_format_info</a>. </p>
<dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a708ed76801eb84544075e21fe8a07652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="format_8h.html#a708ed76801eb84544075e21fe8a07652">pa_encoding</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the type of encoding used in a stream or accepted by a sink. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a708ed76801eb84544075e21fe8a07652a1314110ee09c543c975b3ebdffe5bf70"></a>PA_ENCODING_ANY&#160;</td><td class="fielddoc">
<p>Any encoding format, PCM or compressed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a708ed76801eb84544075e21fe8a07652af5b3680520cee5f542b4d3d1b1c4e71f"></a>PA_ENCODING_PCM&#160;</td><td class="fielddoc">
<p>Any PCM format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a708ed76801eb84544075e21fe8a07652af570614498d7843f30f2860d14a8318a"></a>PA_ENCODING_AC3_IEC61937&#160;</td><td class="fielddoc">
<p>AC3 data encapsulated in IEC 61937 header/padding. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a708ed76801eb84544075e21fe8a07652a080fa22cf987bdc4b64328984693d9ba"></a>PA_ENCODING_EAC3_IEC61937&#160;</td><td class="fielddoc">
<p>EAC3 data encapsulated in IEC 61937 header/padding. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a708ed76801eb84544075e21fe8a07652a37ea55639a90b284526d4c29c86737e5"></a>PA_ENCODING_MPEG_IEC61937&#160;</td><td class="fielddoc">
<p>MPEG-1 or MPEG-2 (Part 3, not AAC) data encapsulated in IEC 61937 header/padding. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a708ed76801eb84544075e21fe8a07652ad97283df564ca82862896059fa5877ce"></a>PA_ENCODING_DTS_IEC61937&#160;</td><td class="fielddoc">
<p>DTS data encapsulated in IEC 61937 header/padding. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a708ed76801eb84544075e21fe8a07652a96bfd1eb3dea46d8f05abac6cf060aec"></a>PA_ENCODING_MPEG2_AAC_IEC61937&#160;</td><td class="fielddoc">
<p>MPEG-2 AAC data encapsulated in IEC 61937 header/padding. </p>
<dl class="section since"><dt>Since</dt><dd>4.0 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a708ed76801eb84544075e21fe8a07652a6183eb06c06e2d708b7423da49824bd4"></a>PA_ENCODING_MAX&#160;</td><td class="fielddoc">
<p>Valid encoding types must be less than this value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a708ed76801eb84544075e21fe8a07652a1f9111d9e6ce5a7d631a9cf256cded52"></a>PA_ENCODING_INVALID&#160;</td><td class="fielddoc">
<p>Represents an invalid encoding. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a86db8f0013a38e9a0f18ed69859a4007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007">pa_prop_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the type of value type of a property on a <a class="el" href="structpa__format__info.html">pa_format_info</a>. </p>
<dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a86db8f0013a38e9a0f18ed69859a4007a10142fbf5a15bbdac6153afc1f3965bf"></a>PA_PROP_TYPE_INT&#160;</td><td class="fielddoc">
<p>Integer property. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a86db8f0013a38e9a0f18ed69859a4007a5b7b6fc0c6064e1653109e2e239606f8"></a>PA_PROP_TYPE_INT_RANGE&#160;</td><td class="fielddoc">
<p>Integer range property. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a86db8f0013a38e9a0f18ed69859a4007ad045693657b6cbdf25a4f562b1a4b621"></a>PA_PROP_TYPE_INT_ARRAY&#160;</td><td class="fielddoc">
<p>Integer array property. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a86db8f0013a38e9a0f18ed69859a4007a04e9b28bc24156fec65d0208eeffe35e"></a>PA_PROP_TYPE_STRING&#160;</td><td class="fielddoc">
<p>String property. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a86db8f0013a38e9a0f18ed69859a4007a4ab87daa27459bbed1cead84800135c8"></a>PA_PROP_TYPE_STRING_ARRAY&#160;</td><td class="fielddoc">
<p>String array property. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a86db8f0013a38e9a0f18ed69859a4007adf3b133ae062ed88366c26d3645027c7"></a>PA_PROP_TYPE_INVALID&#160;</td><td class="fielddoc">
<p>Represents an invalid type. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad96df235255893807a779cf986a322ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="format_8h.html#a078cbc9162779d7ea206b0546508a71b">pa_encoding_t</a> pa_encoding_from_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string of the form returned by <em><a class="el" href="format_8h.html#ab26d3d38076ec1253877b56bb6e4c5a1" title="Returns a printable string representing the given encoding type. ">pa_encoding_to_string()</a></em> back to a <em>pa_encoding_t</em>. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab26d3d38076ec1253877b56bb6e4c5a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pa_encoding_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="format_8h.html#a078cbc9162779d7ea206b0546508a71b">pa_encoding_t</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a printable string representing the given encoding type. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="adcb74d9b96e4e7f2bf446ccb59fe795b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__format__info.html">pa_format_info</a>* pa_format_info_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <em><a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a></em> struct and representing the same format as <em>src</em>. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad4a85d0c897cda925339194a6afbf4f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <em><a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a></em> structure. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4e6c84b0e37e33cae25efd059d222d5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_free_string_array </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a string array returned by <a class="el" href="format_8h.html#a1c50248324fd57eb989ca898a5618fbe">pa_format_info_get_prop_string_array</a>. </p>
<dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1cfd380549e94849b9bd29d43d62b593"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__format__info.html">pa_format_info</a>* pa_format_info_from_sample_spec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to take a <em><a class="el" href="structpa__sample__spec.html" title="A sample format and attribute specification. ">pa_sample_spec</a></em> and generate the corresponding <em><a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a></em>. </p>
<p>Note that if you want the server to choose some of the stream parameters, for example the sample rate, so that they match the device parameters, then you shouldn't use this function. In order to allow the server to choose a parameter value, that parameter must be left unspecified in the <a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a> object, and this function always specifies all parameters. An exception is the channel map: if you pass NULL for the channel map, then the channel map will be left unspecified, allowing the server to choose it.</p>
<dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab8df9952b866161e257807dfe5da4357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__format__info.html">pa_format_info</a>* pa_format_info_from_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a human-readable string of the form generated by <em><a class="el" href="format_8h.html#acebcc293f5e695a6c171d94e2d1f17a3" title="Return a human-readable string representing the given format. ">pa_format_info_snprint()</a></em> into a <a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a> structure. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a385d73fe57a2c2dfd28e9eca48f6c408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_format_info_get_prop_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an integer property from the given format info. </p>
<p>Returns 0 on success and a negative integer on failure. </p><dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a662935ca585b97d292336e638c2d2bb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_format_info_get_prop_int_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an integer array property from the given format info. </p>
<p><em>values</em> contains the values and <em>n_values</em> contains the number of elements. The caller must free <em>values</em> using <a class="el" href="xmalloc_8h.html#a975c3f1d400a40ede0d5e79bb8876008">pa_xfree</a>. Returns 0 on success and a negative integer on failure. </p><dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab8e6eaecf82ee84f084b7654d938b9cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_format_info_get_prop_int_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an integer range property from the given format info. </p>
<p>Returns 0 on success and a negative integer on failure. </p><dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8bb07a605cdfae5ada7918e01aa0872c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_format_info_get_prop_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a string property from the given format info. </p>
<p>The caller must free the returned string using <a class="el" href="xmalloc_8h.html#a975c3f1d400a40ede0d5e79bb8876008">pa_xfree</a>. Returns 0 on success and a negative integer on failure. </p><dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1c50248324fd57eb989ca898a5618fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_format_info_get_prop_string_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a string array property from the given format info. </p>
<p><em>values</em> contains the values and <em>n_values</em> contains the number of elements. The caller must free <em>values</em> using <a class="el" href="format_8h.html#a4e6c84b0e37e33cae25efd059d222d5c">pa_format_info_free_string_array</a>. Returns 0 on success and a negative integer on failure. </p><dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a87728336c103aaac4c5e76d2c65f4cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="format_8h.html#a86db8f0013a38e9a0f18ed69859a4007">pa_prop_type_t</a> pa_format_info_get_prop_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the type of property <em>key</em> in a given <a class="el" href="structpa__format__info.html">pa_format_info</a>. </p>
<dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a71d871a0d9c0624d17a6fe12be0a548a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_format_info_is_compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-zero if the format represented by <em>first</em> is a subset of the format represented by <em>second</em>. </p>
<p>This means that <em>second</em> must have all the fields that <em>first</em> does, but the reverse need not be true. This is typically expected to be used to check if a stream's format is compatible with a given sink. In such a case, <em>first</em> would be the sink's format and <em>second</em> would be the stream's. </p><dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8c48d16d0851791265bdb33ce81b749b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_format_info_is_pcm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-zero when the format info structure represents a PCM (i.e. uncompressed data) format. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a656b51bb7c82883e4cad92b134625942"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpa__format__info.html">pa_format_info</a>* pa_format_info_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new <em><a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a></em> structure. </p>
<p>Clients must initialise at least the encoding field themselves. </p><dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a2e6894e4e8bbb8ac23928f24d8d4b05c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_set_channel_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to set the channel map as a property on the given format. </p>
<p>Note for PCM: If the channel map is left unspecified in the <a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a> object, then the server will select the stream channel map. In that case the stream channel map will most likely match the device channel map, meaning that remixing will be avoided.</p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6238546c60f370e8171b274feac7cb70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_set_channels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to set the number of channels as a property on the given format. </p>
<p>Note for PCM: If the channel count is left unspecified in the <a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a> object, then the server will select the stream channel count. In that case the stream channel count will most likely match the device channel count, meaning that up/downmixing will be avoided.</p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a69567649133e4907c6a25e7baaa95d29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_set_prop_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an integer property on the given format info. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a422a3d83da63a6e778f1a40bc3540667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_set_prop_int_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a property with a list of integer values on the given format info. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4faf1af2d146f848d1e31f276d4901c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_set_prop_int_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a property which can have any value in a given integer range on the given format info. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a3c0ad5ff976e2e3347b3bb98b0748b7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_set_prop_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a string property on the given format info. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a5ae53ecf0d5b56a63aead1ff56f1cb25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_set_prop_string_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a property with a list of string values on the given format info. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a01cdeda2c082cf6a006b0b08102268c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_set_rate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to set the sampling rate as a property on the given format. </p>
<p>Note for PCM: If the sample rate is left unspecified in the <a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a> object, then the server will select the stream sample rate. In that case the stream sample rate will most likely match the device sample rate, meaning that sample rate conversion will be avoided.</p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6e43baade49ac428880361b10d66d08e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pa_format_info_set_sample_format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sample_8h.html#a41051ceaa5cfbe60c9b176deb7bfed0e">pa_sample_format_t</a>&#160;</td>
          <td class="paramname"><em>sf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to set the sample format as a property on the given format. </p>
<p>Note for PCM: If the sample format is left unspecified in the <a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a> object, then the server will select the stream sample format. In that case the stream sample format will most likely match the device sample format, meaning that sample format conversion will be avoided.</p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="acebcc293f5e695a6c171d94e2d1f17a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pa_format_info_snprint </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable string representing the given format. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a092e9e20e51cd2b3b72acccc7d10ef15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_format_info_to_sample_spec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpa__sample__spec.html">pa_sample_spec</a> *&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpa__channel__map.html">pa_channel_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to generate a <em><a class="el" href="structpa__sample__spec.html" title="A sample format and attribute specification. ">pa_sample_spec</a></em> and <em><a class="el" href="structpa__channel__map.html" title="A channel map which can be used to attach labels to specific channels of a stream. ">pa_channel_map</a></em> corresponding to a given <em><a class="el" href="structpa__format__info.html" title="Represents the format of data provided in a stream or processed by a sink. ">pa_format_info</a></em>. </p>
<p>The conversion for PCM formats is straight-forward. For non-PCM formats, if there is a fixed size-time conversion (i.e. all IEC61937-encapsulated formats), a "fake" sample spec whose size-time conversion corresponds to this format is provided and the channel map argument is ignored. For formats with variable size-time conversion, this function will fail. Returns a negative integer if conversion failed and 0 on success. </p><dl class="section since"><dt>Since</dt><dd>2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9efd301cfd24b37737c6a2e2b47c9261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pa_format_info_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpa__format__info.html">pa_format_info</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-zero when the format info structure is valid. </p>
<dl class="section since"><dt>Since</dt><dd>1.0 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_ec5b0a79aff2db41fe5d1b9326f09c28.html">pulse</a></li><li class="navelem"><a class="el" href="format_8h.html">format.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
